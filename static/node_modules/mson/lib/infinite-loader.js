"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _cloneDeep = _interopRequireDefault(require("lodash/cloneDeep"));

var _isEqual = _interopRequireDefault(require("lodash/isEqual"));

// TODO: improve the loading when scrolling up so that the user can "jump" to previous pages.
// Currently, when we scroll up the pages are loaded in reverse order, which means that it can take
// a while to get to where the user has scrolled. Instead, clear all the items and start fresh from
// the current place--may need to approximate it. Will there be problems with this as the height of
// the items is variable?
// NOTE: we cannot use react-virtualized as react-virtualized doesn't appear to work with responsive
// content like MaterialUI's grid.
// NOTE: to simplify the logic by removing the need to calculate the itemsPerRow when the screen
// size changes, we simply expect itemsPerPage to be a multiple of 4. This assumes that the max
// number of columns that will be shown on any screen is 4 and that the grid downsizes by a factor
// of 2, i.e. 4 => 2 => 1. With this assumption we can be sure that the cells in the grid will not
// shift as we remove/add entire rows and not partial rows. In the future we may decide that we want
// to support an odd number of columns. This will significantly increase the complexity, but can be
// accomplished by calculating the following on window resize: 1. itemsPerPage, 2. Select a previous
// item for buffer top so that buffer aligns with items per row.
// |    Spacer     |
// |---------------|
// |  Buffer Top   |
// |      ...      |
// |  - - - - - -  |
// |   Viewport    |
// |  - - - - - -  |
// |      ...      |
// | Buffer Bottom |
// |---------------|
// |  End Screen   |
var InfiniteLoader =
/*#__PURE__*/
function () {
  function InfiniteLoader(_ref) {
    var onGetAll = _ref.onGetAll,
        onGetItemsPerPage = _ref.onGetItemsPerPage,
        onGetScrollThreshold = _ref.onGetScrollThreshold,
        onGetMaxBufferPages = _ref.onGetMaxBufferPages,
        onGetItemElement = _ref.onGetItemElement,
        onGetSpacerElement = _ref.onGetSpacerElement,
        onRemoveItems = _ref.onRemoveItems,
        onResizeSpacer = _ref.onResizeSpacer,
        onSetBufferTopId = _ref.onSetBufferTopId,
        onGetItem = _ref.onGetItem,
        onGetItems = _ref.onGetItems,
        onGetItemId = _ref.onGetItemId,
        onGetItemCursor = _ref.onGetItemCursor,
        onAddItem = _ref.onAddItem,
        onAddItems = _ref.onAddItems,
        onEmitChange = _ref.onEmitChange,
        onSetIsLoading = _ref.onSetIsLoading,
        onGetOrder = _ref.onGetOrder,
        onGetWhere = _ref.onGetWhere;
    (0, _classCallCheck2.default)(this, InfiniteLoader);
    this._onGetAll = onGetAll;
    this._onGetItemsPerPage = onGetItemsPerPage;
    this._onGetScrollThreshold = onGetScrollThreshold;
    this._onGetMaxBufferPages = onGetMaxBufferPages;
    this._onGetItemElement = onGetItemElement;
    this._onGetSpacerElement = onGetSpacerElement;
    this._onRemoveItems = onRemoveItems;
    this._onResizeSpacer = onResizeSpacer;
    this._onSetBufferTopId = onSetBufferTopId;
    this._onGetItem = onGetItem;
    this._onGetItems = onGetItems;
    this._onSetIsLoading = onSetIsLoading;
    this._onGetOrder = onGetOrder;
    this._onGetWhere = onGetWhere;
    this._onGetItemId = onGetItemId;
    this._onGetItemCursor = onGetItemCursor;
    this._onAddItem = onAddItem;
    this._onAddItems = onAddItems;
    this._onEmitChange = onEmitChange;
    this.reset();
  }

  (0, _createClass2.default)(InfiniteLoader, [{
    key: "_resizeBuffer",
    value: function _resizeBuffer(_ref2) {
      var previous = _ref2.previous;

      if (previous) {
        // We just added to the top of the buffer so remove from the bottom of the buffer
        this._bufferBottomId = this._onRemoveItems(this._bufferBottomId, this._onGetItemsPerPage(), true);

        var item = this._onGetItem(this._bufferBottomId);

        this._bufferBottomCursor = this._onGetItemCursor(item);
      } else {
        var bufferTop = this._onGetItemElement(this._bufferTopId); // We just added to the bottom of the buffer so remove from the top of the buffer


        var newBufferTopId = this._onRemoveItems(this._bufferTopId, this._onGetItemsPerPage());

        var newBufferBegin = this._onGetItemElement(newBufferTopId);

        var dHeight = newBufferBegin.offsetTop - bufferTop.offsetTop; // Resize the spacer to account for the removed items

        this._onResizeSpacer(dHeight);

        this._bufferTopId = newBufferTopId;

        var _item = this._onGetItem(newBufferTopId);

        this._bufferTopCursor = this._onGetItemCursor(_item);
      }
    }
  }, {
    key: "_setDefaults",
    value: function _setDefaults() {
      if (!this._bufferTopCursor) {
        this._bufferTopCursor = this._beginCursor;
        this._bufferTopId = this._beginId;
      }

      if (!this._bufferBottomCursor) {
        this._bufferBottomCursor = this._endCursor;
        this._bufferBottomId = this._endId;
      }
    }
  }, {
    key: "_resetBufferReferences",
    value: function _resetBufferReferences() {
      this._bufferTopId = null;
      this._bufferTopCursor = null;
      this._firstCursor = null;
      this._bufferBottomId = null;
      this._bufferBottomCursor = null;
      this._bufferSize = 0;
    }
  }, {
    key: "reset",
    value: function reset() {
      this._resetBufferReferences();

      this._lastGetAllProps = null;
      this._lastScrollY = null;
      this._spacerResizing = false;
      this._showArchived = false;

      this._onSetBufferTopId(null);

      this._onSetIsLoading(false);

      this._onResizeSpacer(null, 0);
    }
  }, {
    key: "getAll",
    value: function () {
      var _getAll = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(props) {
        var beginId, endId, records, first, last, size, beforeKey;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                beginId = null;
                endId = null;
                props = props ? (0, _cloneDeep.default)(props) : {};
                props.showArchived = this._showArchived;

                if (this._onGetWhere) {
                  props.where = this._onGetWhere();
                }

                if (this._onGetOrder) {
                  props.order = this._onGetOrder();
                }

                if (props.before) {
                  props.last = this._onGetItemsPerPage();
                } else {
                  props.first = this._onGetItemsPerPage();
                } // FUTURE: when getting previous page, could use before just to find beginCursor and then use
                // after with beginCursor so that get same data already in cache when scrolling up. Or, is this
                // optimization not really worth it?


                _context.next = 9;
                return this._getAllDebounced(props);

              case 9:
                records = _context.sent;

                if (!records) {
                  _context.next = 18;
                  break;
                }

                first = null;
                last = null;
                size = records.edges.length;
                beforeKey = props.before ? this._bufferTopId : null;
                _context.next = 17;
                return this._onAddItems(records.edges, beforeKey);

              case 17:
                if (size > 0) {
                  if (!this._firstCursor) {
                    this._firstCursor = records.edges[0].cursor;
                  }

                  first = records.edges[0];
                  beginId = first.node.id;
                  last = records.edges[size - 1];
                  endId = last.node.id;
                  this._beginCursor = first.cursor;
                  this._endCursor = last.cursor;
                  this._beginId = beginId;
                  this._endId = endId;
                  this._bufferSize += size;

                  this._setDefaults(); // We emit records so that we trigger a change even whenever the data changes


                  this._onEmitChange(records);
                }

              case 18:
                return _context.abrupt("return", records);

              case 19:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getAll(_x) {
        return _getAll.apply(this, arguments);
      }

      return getAll;
    }()
  }, {
    key: "_noMoreData",
    value: function _noMoreData(records) {
      return !records || !!records.edges && records.edges.length === 0 || !!records.pageInfo && !records.pageInfo.hasNextPage;
    }
  }, {
    key: "_getAllDebounced",
    value: function () {
      var _getAllDebounced2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2(props) {
        var records;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                // Standardize props
                if (!props.after) {
                  props.after = null;
                }

                if (!props.before) {
                  props.before = null;
                } // Props changing? Debounce duplicates


                if ((0, _isEqual.default)(props, this._lastGetAllProps)) {
                  _context2.next = 10;
                  break;
                }

                this._onSetIsLoading(true);

                this._lastGetAllProps = (0, _cloneDeep.default)(props);
                _context2.next = 7;
                return this._onGetAll(props);

              case 7:
                records = _context2.sent;

                // No more data?
                if (this._noMoreData(records)) {
                  // Set isLoading to false as the UI will not be changed so the UI will not set isLoading
                  this._onSetIsLoading(false);
                }

                return _context2.abrupt("return", records);

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _getAllDebounced(_x2) {
        return _getAllDebounced2.apply(this, arguments);
      }

      return _getAllDebounced;
    }()
  }, {
    key: "_getMore",
    value: function () {
      var _getMore2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3(_ref3) {
        var previous, props, records, maxBufferSize, oldBufferTopId;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                previous = _ref3.previous;
                // FUTURE: we may want to use the previous hasNextPage to determine whether to attempt to get
                // the next page. This will prevent us from trying to get another page when we know there is no
                // other page. If we make this change then we'll need to worry about updating this status once
                // we implement subscriptions and we detect that more data has been added. For now, we let the
                // debounce logic prevent duplicate API requests.
                props = {};

                if (previous) {
                  props.before = this._bufferTopCursor;
                } else {
                  props.after = this._bufferBottomCursor;
                }

                _context3.next = 5;
                return this.getAll(props);

              case 5:
                records = _context3.sent;
                maxBufferSize = this._onGetMaxBufferPages() * this._onGetItemsPerPage();
                this._lastMoreWasPrevious = previous; // Not debounced?

                if (records && records.edges.length > 0) {
                  if (previous) {
                    oldBufferTopId = this._bufferTopId; // Move buffer pointers up

                    this._bufferTopCursor = this._beginCursor;
                    this._bufferTopId = this._beginId; // Resize the spacer to account for the inserted items after the DOM has been upated. Note:
                    // we cannot call _onResizeSpacer() directly as our items may have yet to be rendered and
                    // therefore we would have no way of knowing how much to adjust our spacer as the size of
                    // our items is variable.

                    this._onSetBufferTopId(oldBufferTopId);
                  } else {
                    // Move buffer pointers down
                    this._bufferBottomCursor = this._endCursor;
                    this._bufferBottomId = this._endId;
                  } // Has our buffer reached its max size?


                  if (this._bufferSize > maxBufferSize) {
                    this._resizeBuffer({
                      previous: previous
                    });
                  }
                }

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _getMore(_x3) {
        return _getMore2.apply(this, arguments);
      }

      return _getMore;
    }()
  }, {
    key: "resizeSpacer",
    value: function resizeSpacer(bufferTopId) {
      var bufferTop = this._onGetItemElement(bufferTopId); // Has the buffer top been rendered?


      if (bufferTop) {
        var spacer = this._onGetSpacerElement();

        var dHeight = spacer.offsetTop + spacer.offsetHeight - bufferTop.offsetTop;

        if (dHeight > 0) {
          // Only set to true if we are actually resizing or else the React layer will never detect a
          // change in spacerHeight
          this._spacerResizing = true;
        }

        this._onResizeSpacer(dHeight);
      }
    }
  }, {
    key: "_shouldLoadPrevious",
    value: function _shouldLoadPrevious(scrollY) {
      // Elements may not exist if they have not yet been rendered
      var bufferTop = this._onGetItemElement(this._bufferTopId);

      var beginning = this.beginningLoaded();
      return bufferTop && scrollY < bufferTop.offsetTop + this._onGetScrollThreshold() && !beginning;
    }
  }, {
    key: "_shouldLoadNext",
    value: function _shouldLoadNext(scrollY) {
      // Elements may not exist if they have not yet been rendered
      var bufferBottom = this._onGetItemElement(this._bufferBottomId);

      return bufferBottom && scrollY > bufferBottom.offsetTop + bufferBottom.offsetHeight - this._onGetScrollThreshold();
    }
  }, {
    key: "scroll",
    value: function () {
      var _scroll = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee4(_ref4) {
        var scrollY, down;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                scrollY = _ref4.scrollY;
                down = !this._lastScrollY || scrollY >= this._lastScrollY ? true : false;
                this._lastScrollY = scrollY;

                if (!this._spacerResizing) {
                  _context4.next = 5;
                  break;
                }

                return _context4.abrupt("return");

              case 5:
                if (!(!down && this._shouldLoadPrevious(scrollY))) {
                  _context4.next = 10;
                  break;
                }

                _context4.next = 8;
                return this._getMore({
                  previous: true
                });

              case 8:
                _context4.next = 13;
                break;

              case 10:
                if (!(down && this._shouldLoadNext(scrollY))) {
                  _context4.next = 13;
                  break;
                }

                _context4.next = 13;
                return this._getMore({
                  previous: false
                });

              case 13:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function scroll(_x4) {
        return _scroll.apply(this, arguments);
      }

      return scroll;
    }()
  }, {
    key: "setSpacerResizing",
    value: function setSpacerResizing(resizing) {
      this._spacerResizing = resizing; // Are we no longer resizing, was the last getMore for a previous page and have we scrolled to a
      // position where more previous items are needed? We also check beginningLoaded() as this
      // reduces the likelyhood of a race condition where the user scrolls all the way up and then
      // very quickly scrolls down and up repeatedly, resulting in an inproperly sized spacer. TODO:
      // properly fix this as it is still possible to encounter this race condition.

      if (!resizing && this._lastMoreWasPrevious && this._shouldLoadPrevious(window.scrollY) && !this.beginningLoaded()) {
        // We kick off another getMore just in the case the user has scrolled up and now waiting for
        // earlier items to load.
        // We don't await here as we are just kicking of a tick to do the loading
        this._getMore({
          previous: true
        });
      }
    }
  }, {
    key: "beginningLoaded",
    value: function beginningLoaded() {
      return this._bufferTopCursor === this._firstCursor;
    }
  }, {
    key: "setShowArchived",
    value: function setShowArchived(showArchived) {
      this._showArchived = showArchived;
    }
  }, {
    key: "removeItem",
    value: function removeItem(id) {
      // Are we removing one of the buffer references?
      if (id === this._bufferTopId || id === this._bufferBottomId) {
        // Reposition the buffer references as they need to be accurate when we resize the buffer
        var reverse = id === this._bufferBottomId;

        var items = this._onGetItems(id, reverse);

        var newId = null;
        var newCursor = null;
        var i = 0;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var item = _step.value;
            newId = this._onGetItemId(item);
            newCursor = this._onGetItemCursor(item); // Exit loop as we only need the second item

            if (i++ === 1) {
              break;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        if (newId) {
          if (id === this._bufferTopId) {
            this._bufferTopId = newId;
            this._bufferTopCursor = newCursor;
            this._firstCursor = newCursor;
          } else {
            // id === this._bufferBottomId
            this._bufferBottomId = newId;
            this._bufferBottomCursor = newCursor;
          }
        } else {
          this._resetBufferReferences();
        }
      }
    }
  }]);
  return InfiniteLoader;
}();

exports.default = InfiniteLoader;