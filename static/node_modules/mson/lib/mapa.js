"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _events = _interopRequireDefault(require("events"));

// Objects aren't ordered so we use an object and array so that we can key the values while
// maintaining order. The Map construct in ES6 solves some of these problems, but doesn't deal with
// getting the next value--instead you have to get the entire list of values. Mapa implements some a
// similar API to Map, but adds some extra functionality.
// We use a doubly linked list so that we can easily delete an item and still iterate forward and
// reverse. The downside is that iteration is a little slower than using an array. An alternative
// approach is to use an array and delete (not splice) items and then mark those items as deleted.
// The downside is that these deletions leave tombstones so they are they will eventually add up.
// TODO:
// - Open source Mapa as its own project? Mention at
//   https://stackoverflow.com/a/5773972/2831606
var Mapa =
/*#__PURE__*/
function (_events$EventEmitter) {
  (0, _inherits2.default)(Mapa, _events$EventEmitter);

  function Mapa() {
    var _this;

    (0, _classCallCheck2.default)(this, Mapa);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Mapa).call(this));

    _this.clear();

    return _this;
  }

  (0, _createClass2.default)(Mapa, [{
    key: "clear",
    value: function clear() {
      this._firstKey = null;
      this._lastKey = null;
      this._length = 0;
      this._items = {};
    }
  }, {
    key: "has",
    value: function has(key) {
      return this._items[key] !== undefined;
    }
  }, {
    key: "_nullOrUndefined",
    value: function _nullOrUndefined(value) {
      return value === undefined || value === null;
    }
  }, {
    key: "_insertBefore",
    value: function _insertBefore(key, value, beforeKey) {
      var prevKey = this._lastKey;

      if (!this._nullOrUndefined(beforeKey)) {
        this._throwIfMissing(beforeKey);

        prevKey = this._items[beforeKey].prevKey;
      } else {
        beforeKey = null;
      } // Create item that links backwards to the previous item


      var item = {
        key: key,
        prevKey: prevKey,
        nextKey: beforeKey,
        value: value
      }; // Are we appending?

      if (beforeKey === null) {
        // Is there a last item?
        if (this._lastKey !== null) {
          // Link the last item forward to out new item
          this._items[this._lastKey].nextKey = key;
        } // Update the _lastKey


        this._lastKey = key;
      } else {
        // Link the next item backwards to our new item
        this._items[beforeKey].prevKey = key; // Is there a previous item that needs to be linked forward to our new item?

        if (prevKey !== null) {
          this._items[prevKey].nextKey = key;
        }
      } // Add the new item


      this._items[key] = item; // Is this the 1st item?

      if (this._firstKey === null || beforeKey === this._firstKey) {
        this._firstKey = key;
      } // Increment our length counter


      this._length++;
      return item;
    }
  }, {
    key: "_insertAfter",
    value: function _insertAfter(key, value, afterKey) {
      var nextKey = this._firstKey;

      if (!this._nullOrUndefined(afterKey)) {
        this._throwIfMissing(afterKey);

        nextKey = this._items[afterKey].nextKey;
      } else {
        afterKey = null;
      } // Create item that links backwards to the previous item


      var item = {
        key: key,
        prevKey: afterKey,
        nextKey: nextKey,
        value: value
      }; // Are we prepending?

      if (afterKey === null) {
        // Is there a first item?
        if (this._firstKey !== null) {
          // Link the first item backward to out new item
          this._items[this._firstKey].prevKey = key;
        } // Update the _firstKey


        this._firstKey = key;
      } else {
        // Link the previous item forward to our new item
        this._items[afterKey].nextKey = key; // Is there a next item that needs to be linked backwards to our new item?

        if (nextKey !== null) {
          this._items[nextKey].prevKey = key;
        }
      } // Add the new item


      this._items[key] = item; // Is this the last item?

      if (this._lastKey === null || afterKey === this._lastKey) {
        this._lastKey = key;
      } // Increment our length counter


      this._length++;
      return item;
    }
  }, {
    key: "_insert",
    value: function _insert(key, value, beforeKey, afterKey) {
      if (beforeKey !== undefined && afterKey !== undefined) {
        throw new Error('cannot specify both beforeKey and afterKey');
      }

      if (afterKey !== undefined) {
        return this._insertAfter(key, value, afterKey);
      } else {
        return this._insertBefore(key, value, beforeKey);
      }
    }
  }, {
    key: "_update",
    value: function _update(key, value, beforeKey, afterKey) {
      var item = this._items[key]; // Is the item moving?

      if (beforeKey !== undefined && item.nextKey !== beforeKey && beforeKey !== key || afterKey !== undefined && item.prevKey !== afterKey && afterKey !== key) {
        this._delete(key);

        item = this._insert(key, value, beforeKey, afterKey);
      } else {
        // Update
        item.value = value;
      }

      return item;
    }
  }, {
    key: "set",
    value: function set(key, value, beforeKey, afterKey) {
      var item = null;

      if (this._nullOrUndefined(key)) {
        throw new Error('key cannot be null or undefined');
      } else if (this.has(key)) {
        item = this._update(key, value, beforeKey, afterKey);
        this.emitChange('update', item);
      } else {
        item = this._insert(key, value, beforeKey, afterKey);
        this.emitChange('create', item);
      }

      return item;
    }
  }, {
    key: "_throwIfMissing",
    value: function _throwIfMissing(key) {
      if (!this.has(key)) {
        throw new Error('value is missing for key ' + key);
      }
    }
  }, {
    key: "get",
    value: function get(key) {
      this._throwIfMissing(key);

      return this._items[key].value;
    }
  }, {
    key: "walkForward",
    value:
    /*#__PURE__*/
    _regenerator.default.mark(function walkForward(key, fullEntry) {
      var item;
      return _regenerator.default.wrap(function walkForward$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!this.has(key)) {
                _context.next = 11;
                break;
              }

              item = this._items[key];

              if (!fullEntry) {
                _context.next = 7;
                break;
              }

              _context.next = 5;
              return [key, item.value];

            case 5:
              _context.next = 9;
              break;

            case 7:
              _context.next = 9;
              return item.value;

            case 9:
              if (!(item.nextKey !== null)) {
                _context.next = 11;
                break;
              }

              return _context.delegateYield(this.walkForward(item.nextKey, fullEntry), "t0", 11);

            case 11:
            case "end":
              return _context.stop();
          }
        }
      }, walkForward, this);
    })
  }, {
    key: "walkBackward",
    value:
    /*#__PURE__*/
    _regenerator.default.mark(function walkBackward(key, fullEntry) {
      var item;
      return _regenerator.default.wrap(function walkBackward$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!this.has(key)) {
                _context2.next = 11;
                break;
              }

              item = this._items[key];

              if (!fullEntry) {
                _context2.next = 7;
                break;
              }

              _context2.next = 5;
              return [key, item.value];

            case 5:
              _context2.next = 9;
              break;

            case 7:
              _context2.next = 9;
              return item.value;

            case 9:
              if (!(item.prevKey !== null)) {
                _context2.next = 11;
                break;
              }

              return _context2.delegateYield(this.walkBackward(item.prevKey, fullEntry), "t0", 11);

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, walkBackward, this);
    })
  }, {
    key: "values",
    value:
    /*#__PURE__*/
    _regenerator.default.mark(function values(startKey, reverse) {
      return _regenerator.default.wrap(function values$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!reverse) {
                _context3.next = 4;
                break;
              }

              return _context3.delegateYield(this.walkBackward(startKey ? startKey : this._lastKey), "t0", 2);

            case 2:
              _context3.next = 5;
              break;

            case 4:
              return _context3.delegateYield(this.walkForward(startKey ? startKey : this._firstKey), "t1", 5);

            case 5:
            case "end":
              return _context3.stop();
          }
        }
      }, values, this);
    })
  }, {
    key: "entries",
    value:
    /*#__PURE__*/
    _regenerator.default.mark(function entries(startKey, reverse) {
      return _regenerator.default.wrap(function entries$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (!reverse) {
                _context4.next = 4;
                break;
              }

              return _context4.delegateYield(this.walkBackward(startKey ? startKey : this._lastKey, true), "t0", 2);

            case 2:
              _context4.next = 5;
              break;

            case 4:
              return _context4.delegateYield(this.walkForward(startKey ? startKey : this._firstKey, true), "t1", 5);

            case 5:
            case "end":
              return _context4.stop();
          }
        }
      }, entries, this);
    })
  }, {
    key: "forEach",
    value: function forEach(onValue) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var entry = _step.value;
          var last = entry[0] === this._lastKey;
          var again = onValue(entry[1], entry[0], last); // Do we need to exit prematurely?

          if (again === false) {
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } // Alias for forEach

  }, {
    key: "each",
    value: function each(onValue) {
      this.forEach(onValue);
    }
  }, {
    key: "map",
    value: function map(onValue) {
      var values = [];
      this.forEach(function (value, key) {
        values.push(onValue(value, key));
      });
      return values;
    }
  }, {
    key: "_delete",
    value: function _delete(key) {
      this._throwIfMissing(key);

      var item = this._items[key]; // Are we sandwiched between items?

      if (item.prevKey !== null && item.nextKey !== null) {
        // Point the surrounding items to each other
        var prevItem = this._items[item.prevKey];
        var nextItem = this._items[item.nextKey];
        prevItem.nextKey = item.nextKey;
        nextItem.prevKey = item.prevKey;
      } else {
        // Are we deleting the 1st item?
        if (item.prevKey === null) {
          // Is there a next item?
          if (item.nextKey !== null) {
            // The nextItem no longer has a previous item
            var _nextItem = this._items[item.nextKey];
            _nextItem.prevKey = null;
          } // Pick the next item as the first item


          this._firstKey = item.nextKey;
        } // Are we deleting the last item?


        if (item.nextKey === null) {
          // Is there a previous item?
          if (item.prevKey !== null) {
            // The prevItem no longer has a next item
            var _prevItem = this._items[item.prevKey];
            _prevItem.nextKey = null;
          } // Pick the previous item as the last item


          this._lastKey = item.prevKey;
        }
      } // Decrement the length


      this._length--; // Delete the item

      delete this._items[key];
      return item;
    }
  }, {
    key: "emitChange",
    value: function emitChange(name, value) {
      this.emit(name, value);
      this.emit('$change', name, value);
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      var item = this._delete(key);

      this.emitChange('delete', item);
      return item;
    }
  }, {
    key: "length",
    value: function length() {
      return this._length;
    }
  }, {
    key: "previousKey",
    value: function previousKey(key) {
      this._throwIfMissing(key);

      return this._items[key].prevKey;
    }
  }, {
    key: "previous",
    value: function previous(key) {
      return this.get(this.previousKey(key));
    }
  }, {
    key: "first",
    value: function first() {
      return this.get(this._firstKey);
    }
  }, {
    key: "firstKey",
    value: function firstKey() {
      return this._firstKey;
    }
  }, {
    key: "hasFirst",
    value: function hasFirst() {
      return this.has(this._firstKey);
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return !this.hasFirst();
    }
  }, {
    key: "nextKey",
    value: function nextKey(key) {
      this._throwIfMissing(key);

      return this._items[key].nextKey;
    }
  }, {
    key: "next",
    value: function next(key) {
      return this.get(this.nextKey(key));
    }
  }, {
    key: "last",
    value: function last() {
      return this.get(this._lastKey);
    }
  }, {
    key: "lastKey",
    value: function lastKey() {
      return this._lastKey;
    }
  }, {
    key: "hasLast",
    value: function hasLast() {
      return this.has(this._lastKey);
    } // // FUTURE: we could speed this up by creating an index for the indexes
    // indexOf(key) {
    //   let index = 0;
    //   for (const entry of this.entries()) {
    //     if (entry[0] === key) {
    //       return index;
    //     }
    //     index++;
    //   }
    // }

  }]);
  return Mapa;
}(_events.default.EventEmitter);

exports.default = Mapa;