"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _events2 = _interopRequireDefault(require("events"));

var _registrar = _interopRequireDefault(require("../compiler/registrar"));

var _utils = _interopRequireDefault(require("../utils"));

var _each = _interopRequireDefault(require("lodash/each"));

var _difference = _interopRequireDefault(require("lodash/difference"));

var _cloneDeepWith = _interopRequireDefault(require("lodash/cloneDeepWith"));

var _mapa = _interopRequireDefault(require("../mapa"));

var _propertyNotDefinedError = _interopRequireDefault(require("./property-not-defined-error"));

var nextKey = 0;

var _getNextKey = function getNextKey() {
  return nextKey++;
}; // NOTE:
// - Get and set designed so that easy to add functionality later on set and get, including via
//   event listeners
// - The props are placed directly on this object as opposed to onto say a "_props" field. This has
//   the advantage of making it less verbose to access, e.g. comp._foo instead of comp._props.foo.
// - We attempted to require all access to all props via get() and set(), but this can cause
//   infinite recursion, e.g. when a get() calls itself either directly or via some inherited logic.


var BaseComponent =
/*#__PURE__*/
function (_events$EventEmitter) {
  (0, _inherits2.default)(BaseComponent, _events$EventEmitter);
  (0, _createClass2.default)(BaseComponent, [{
    key: "_getBaseComponentSchema",
    value: function _getBaseComponentSchema() {
      return {
        component: 'Form',
        fields: [{
          // This field is just for the MSON definition
          name: 'component',
          component: 'TextField'
        }, {
          name: 'name',
          component: 'TextField',
          label: 'Name',
          docLevel: 'basic',
          help: 'A unique variable name' // Not required as a lot of components don't need to be named
          // required: true

        }, {
          name: 'listeners',
          // TODO: proper schema
          component: 'Field'
        }, {
          name: 'schema',
          component: 'FormField',
          form: {
            // TODO: should there be a SchemaForm?
            component: 'ObjectForm'
          }
        }, {
          name: 'isStore',
          component: 'BooleanField'
        }, {
          name: 'didCreate',
          component: 'BooleanField'
        }, {
          // True if the component should never be sent to the front end, e.g. if they contain
          // secrets
          name: 'backEndOnly',
          component: 'BooleanField'
        }, {
          name: 'parent',
          component: 'Field'
        }, {
          name: 'muteCreate',
          component: 'BooleanField'
        }, {
          name: 'disableSubEvents',
          component: 'BooleanField'
        }, {
          name: 'docLevel',
          component: 'SelectField',
          options: [{
            value: 'basic',
            label: 'Basic'
          }, {
            value: 'advanced',
            label: 'Advanced'
          }]
        }]
      };
    }
  }, {
    key: "_emitCreate",
    value: function _emitCreate() {
      this.emitChange('create');

      if (!this._hasListenerForEvent('create')) {
        // There are no create listeners so emit a created event
        this._emitDidCreate();
      }
    }
  }, {
    key: "_setDebugId",
    value: function _setDebugId() {
      // Used to identify instances when debugging
      this._debugId = Math.random();
    }
  }, {
    key: "_emitCreateIfNotMuted",
    value: function _emitCreateIfNotMuted() {
      var _this2 = this;

      if (!this.get('muteCreate')) {
        // Execute on next tick so that there is time for any wrapping components to finish the
        // wrapping. This also gives the caller a chance to listen for the create event before it is
        // emitted.
        setTimeout(function () {
          // Emit the create event after we have set up the initial listeners
          _this2._emitCreate();
        });
      }
    }
  }]);

  function BaseComponent(props) {
    var _this;

    (0, _classCallCheck2.default)(this, BaseComponent);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(BaseComponent).call(this, props)); // For mocking

    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_className", 'Component');
    _this._registrar = _registrar.default;

    _this._setDebugId();

    _this._listenerEvents = {};
    _this._subEvents = {};
    _this._isLoaded = false;
    _this._resolveAfterCreate = _utils.default.once((0, _assertThisInitialized2.default)(_this), 'didCreate');
    _this._resolveAfterLoad = _utils.default.once((0, _assertThisInitialized2.default)(_this), 'didLoad'); // this._onWillSet = null;
    // this._onDidSet = null;

    _this._listenToAllChanges(); // Define schema as setting the schema will define the reset of the props


    _this._propNames = ['schema'];
    _this._indexedPropNames = {
      schema: true
    }; // We have to set the name before we create the component as the name is needed to create the
    // component, e.g. to create sub fields using the name as a prefix.

    if (props && props.name !== undefined) {
      // Use setProperty so we don'trigger any events before creation
      _this._setProperty('name', props.name);
    }

    _this._create(props === undefined ? {} : props);

    _this.set(props === undefined ? {} : props);

    _this._emitCreateIfNotMuted();

    _this._setKey();

    return _this;
  }

  (0, _createClass2.default)(BaseComponent, [{
    key: "_setKey",
    value: function _setKey() {
      // Used to create a separate namespace/keyspace for components so that we can do things like
      // trigger a UI update in frameworks like React.
      this._key = _getNextKey();
    }
  }, {
    key: "_create",
    value: function _create(props) {
      // TODO: would it be better if the schema was loaded dynamically and on demand instead of
      // whenever the component is created? In some ways we already have this the schema exists as
      // simple objects until it instantiated. The problem with a lazy setting of the schema is how we
      // would allow schemas to be defined via MSON.
      this.set({
        schema: this._getBaseComponentSchema()
      });

      this._setDefaults(props, {
        docLevel: 'advanced'
      });
    }
  }, {
    key: "emitChange",
    value: function emitChange(name, value) {
      this.emit(name, value);
      this.emit('$change', name, value);
    }
  }, {
    key: "_setProperty",
    value: function _setProperty(name, value) {
      this['_' + name] = value;
    }
  }, {
    key: "_setPropertyAndEmitChange",
    value: function _setPropertyAndEmitChange(name, value) {
      // if (this._onWillSet) {
      //   this._onWillSet(name, value);
      // }
      this._setProperty(name, value);

      this.emitChange(name, value); // if (this._onDidSet) {
      //   this._onDidSet(name, value);
      // }
    }
  }, {
    key: "_setIfDifferent",
    value: function _setIfDifferent(name, value) {
      // Is the value changing? Prevent emitting when the value doesn't change. Note: a previous
      // design treated undefined and null values as equals, but this had to be changed as otherwise
      // we have no construct for detecting when properties are omitted from a MSON definition.
      if (this['_' + name] !== value) {
        this._setPropertyAndEmitChange(name, value);
      }
    }
  }, {
    key: "_push",
    value: function _push(name, value) {
      var values = this._getProperty(name);

      if (!Array.isArray(values)) {
        values = [];
      }

      values.push(value);

      this._set(name, values);
    }
  }, {
    key: "_concat",
    value: function _concat(name, newValues) {
      var values = this._getProperty(name);

      if (!Array.isArray(values)) {
        values = [];
      }

      values = values.concat(newValues);

      this._set(name, values);
    }
  }, {
    key: "has",
    value: function has(name) {
      return this._indexedPropNames[name] !== undefined;
    }
  }, {
    key: "_throwIfNotDefined",
    value: function _throwIfNotDefined(name) {
      if (!this.has(name)) {
        throw new _propertyNotDefinedError.default(this.getClassName() + ': ' + name + ' not defined');
      }
    }
  }, {
    key: "_setIfPropDefined",
    value: function _setIfPropDefined(name, value) {
      this._throwIfNotDefined(name);

      this._setIfDifferent(name, value);
    }
  }, {
    key: "_throwPropertyNotFound",
    value: function _throwPropertyNotFound(propertyNames) {
      throw new _propertyNotDefinedError.default(propertyNames.join('.') + ' not found');
    }
  }, {
    key: "isComponent",
    value: function isComponent(property) {
      return property instanceof BaseComponent || property instanceof _mapa.default;
    }
  }, {
    key: "_getSubProperty",
    value: function _getSubProperty(name, end) {
      var names = name.split('.');
      var property = this;

      if (end === undefined) {
        end = names.length;
      } else if (end < 0) {
        end += names.length;
      }

      var propertyNames = [];

      for (var i = 0; i < end; i++) {
        var nme = names[i];
        propertyNames.push(nme);

        if (this.isComponent(property)) {
          if (!property.has(nme)) {
            this._throwPropertyNotFound(propertyNames);
          }

          property = property.get(nme);
        } else if (property === undefined) {
          propertyNames.pop();

          this._throwPropertyNotFound(propertyNames);
        } else if (property[nme] === undefined) {
          this._throwPropertyNotFound(propertyNames);
        } else {
          property = property[nme];
        }
      }

      return {
        property: property,
        names: names
      };
    }
  }, {
    key: "_set",
    value: function _set(name, value) {
      // Most of the time, name will not be in dot notation so we want to do the quickest possible
      // check
      var hasDot = this._hasDot(name); // Using dot notation?


      if (hasDot) {
        var _this$_getSubProperty = this._getSubProperty(name, -1),
            property = _this$_getSubProperty.property,
            names = _this$_getSubProperty.names;

        var lastName = names[names.length - 1];

        if (this.isComponent(property)) {
          if (property.has(lastName) && this.isComponent(property.get(lastName))) {
            // The last property is a component so we assume that the value is a group of properties
            property.get(lastName).set(value);
          } else {
            property.set((0, _defineProperty2.default)({}, lastName, value));
          }
        } else {
          property[lastName] = value;
        }
      } else {
        // Not dot notation
        this._setIfPropDefined(name, value);
      }
    }
  }, {
    key: "_setIfDefined",
    value: function _setIfDefined(name, value) {
      if (value !== undefined) {
        this._set(name, value);
      }
    }
  }, {
    key: "_setProps",
    value: function _setProps(props) {
      var _this3 = this;

      (0, _each.default)(props, function (value, name) {
        return _this3._setIfDefined(name, value);
      });
    }
  }, {
    key: "_setName",
    value: function _setName(name) {
      this._set('name', name);
    }
  }, {
    key: "_setParent",
    value: function _setParent(parent) {
      this._set('parent', parent);
    }
  }, {
    key: "_setIsStore",
    value: function _setIsStore(isStore) {
      this._set('isStore', isStore);
    }
  }, {
    key: "_setDefaults",
    value: function _setDefaults(props, values) {
      var _this4 = this;

      (0, _each.default)(values, function (value, name) {
        if (props[name] === undefined) {
          _this4._set(name, value);
        }
      });
    }
  }, {
    key: "_emitDidCreate",
    value: function _emitDidCreate() {
      this.set({
        didCreate: true
      });
    }
  }, {
    key: "_emitDidLoad",
    value: function _emitDidLoad() {
      this.emitChange('didLoad');
      this._isLoaded = true;
    } // Note: the layer attribute cannot reside in Globals as Globals depends on component

  }, {
    key: "_getLayer",
    // For mocking
    value: function _getLayer() {
      return this.constructor.getLayer();
    }
  }, {
    key: "_hasListenerForEvent",
    value: function _hasListenerForEvent(event) {
      return !!this._listenerEvents[event];
    }
  }, {
    key: "_hasDot",
    value: function _hasDot(event) {
      return event.indexOf('.') !== -1;
    }
  }, {
    key: "_listenToSubEvent",
    value: function _listenToSubEvent(event) {
      var _this5 = this;

      // Register sub event so that we don't have duplicate listeners
      this._subEvents[event] = true; // Get the sub component

      var _this$_getSubProperty2 = this._getSubProperty(event, -1),
          property = _this$_getSubProperty2.property,
          names = _this$_getSubProperty2.names; // The sub event is the last name


      var subEvent = names[names.length - 1]; // Listen to the event and bubble it up. We choose to bubble up the events and let runListeners
      // take care of the response so that we can reuse the same logic for all listeners. TODO: when
      // is this listener destroyed? Do we need a destroy() function in each component that can
      // release this?

      property.on(subEvent, function (value) {
        return _this5.emitChange(event, value);
      });
    }
  }, {
    key: "_listenIfNewSubEvent",
    value: function _listenIfNewSubEvent(event) {
      // Check on _subEvents is done here to avoid race conditions
      if (this._subEvents[event] === undefined && !this.get('disableSubEvents')) {
        this._listenToSubEvent(event);
      }
    }
  }, {
    key: "_listenIfSubEvent",
    value: function _listenIfSubEvent(event) {
      var _this6 = this;

      // New sub event?
      if (this._hasDot(event)) {
        // We wait until the create event has fired so that we can be sure that the initial properties
        // have been set for by any derived components. Otherwise, the properties may not exist yet.
        // The alternative would be to create the listener when the property is set, but this would
        // add a lot of latency to set() and it probably wouldn't work for components nested within
        // properties.
        this.resolveAfterCreate().then(function () {
          return _this6._listenIfNewSubEvent(event);
        });
      }
    }
  }, {
    key: "_setListeners",
    value: function _setListeners(listeners) {
      var _this7 = this;

      // Listeners are concatentated that they can accumulate through the layers of inheritance. TODO:
      // do we need a construct to clear all previous listeners for an event?
      this._concat('listeners', listeners);

      listeners.forEach(function (listener) {
        var events = Array.isArray(listener.event) ? listener.event : [listener.event];
        events.forEach(function (event) {
          _this7._listenIfSubEvent(event); // Register the event so that we can do a quick lookup later


          _this7._listenerEvents[event] = true;
        });
      });
    }
  }, {
    key: "_emitAfterListenerEvents",
    value: function _emitAfterListenerEvents(event) {
      // Emit event after all actions for the following events so that we can guarantee that data has
      // been loaded.
      switch (event) {
        case 'create':
          this._emitDidCreate();

          break;

        case 'load':
          this._emitDidLoad();

          break;

        default:
          break;
      }
    }
  }, {
    key: "_runAction",
    value: function () {
      var _runAction2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(listener, action, event, args, context) {
        var layer;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                layer = action.get('layer');

                if (!(!this._getLayer() || !layer || layer === this._getLayer())) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt("return", action.run({
                  event: event,
                  component: this,
                  arguments: args,
                  context: context
                }));

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _runAction(_x, _x2, _x3, _x4, _x5) {
        return _runAction2.apply(this, arguments);
      }

      return _runAction;
    }()
  }, {
    key: "_onActionErr",
    value: function _onActionErr(err) {
      // Provide a way to intercept errors from detached actions
      this.emitChange('actionErr', err);
    }
  }, {
    key: "_onDetachedActionErr",
    value: function _onDetachedActionErr(err) {
      if (this._registrar.log) {
        this._registrar.log.error(err);
      }

      this._onActionErr(err);
    }
  }, {
    key: "runListeners",
    value: function () {
      var _runListeners = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2(event, output, context) {
        var _this8 = this;

        var listeners, i, listener, _events, _i, action, runAction;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                listeners = this.get('listeners');

                if (!listeners) {
                  _context2.next = 25;
                  break;
                }

                _context2.t0 = _regenerator.default.keys(listeners);

              case 3:
                if ((_context2.t1 = _context2.t0()).done) {
                  _context2.next = 24;
                  break;
                }

                i = _context2.t1.value;
                listener = listeners[i];
                _events = Array.isArray(listener.event) ? listener.event : [listener.event]; // Listener is for this event?

                if (!(_events.indexOf(event) !== -1)) {
                  _context2.next = 22;
                  break;
                }

                _context2.t2 = _regenerator.default.keys(listener.actions);

              case 9:
                if ((_context2.t3 = _context2.t2()).done) {
                  _context2.next = 22;
                  break;
                }

                _i = _context2.t3.value;
                action = listener.actions[_i];
                runAction = this._runAction(listener, action, event, output, context);

                if (!action.get('detached')) {
                  _context2.next = 17;
                  break;
                }

                // We don't wait for detached actions, but we want to log any errors
                runAction.catch(function (err) {
                  return _this8._onDetachedActionErr(err);
                });
                _context2.next = 20;
                break;

              case 17:
                _context2.next = 19;
                return runAction;

              case 19:
                output = _context2.sent;

              case 20:
                _context2.next = 9;
                break;

              case 22:
                _context2.next = 3;
                break;

              case 24:
                this._emitAfterListenerEvents(event);

              case 25:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function runListeners(_x6, _x7, _x8) {
        return _runListeners.apply(this, arguments);
      }

      return runListeners;
    }()
  }, {
    key: "_runListenersAndEmitError",
    value: function () {
      var _runListenersAndEmitError2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3(event, value) {
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                _context3.next = 3;
                return this.runListeners(event, value);

              case 3:
                _context3.next = 9;
                break;

              case 5:
                _context3.prev = 5;
                _context3.t0 = _context3["catch"](0);

                // Report error via the actionErr event
                this._onActionErr(_context3.t0); // Throw the error so that it is clear that something went wrong even if the user is not
                // listening to the action error


                throw _context3.t0;

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[0, 5]]);
      }));

      function _runListenersAndEmitError(_x9, _x10) {
        return _runListenersAndEmitError2.apply(this, arguments);
      }

      return _runListenersAndEmitError;
    }()
  }, {
    key: "_listenToAllChanges",
    value: function _listenToAllChanges() {
      var _this9 = this;

      this.on('$change',
      /*#__PURE__*/
      function () {
        var _ref = (0, _asyncToGenerator2.default)(
        /*#__PURE__*/
        _regenerator.default.mark(function _callee4(event, value) {
          return _regenerator.default.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  if (!_this9._listenerEvents[event]) {
                    _context4.next = 3;
                    break;
                  }

                  _context4.next = 3;
                  return _this9._runListenersAndEmitError(event, value);

                case 3:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }));

        return function (_x11, _x12) {
          return _ref.apply(this, arguments);
        };
      }());
    }
  }, {
    key: "_pushProp",
    value: function _pushProp(name) {
      // Is the prop missing? The prop may already exist if we are overloading the type in a dervied
      // component
      if (!this.has(name)) {
        this._propNames.push(name);

        this._indexedPropNames[name] = true;
      }
    }
  }, {
    key: "_setSchema",
    value: function _setSchema(schema) {
      var _this10 = this;

      // Schemas are pushed so that they can accumulate through the layers of inheritance
      this._push('schema', schema); // Push props so that we have a fast way of identifying the props for this component


      if (schema.fields) {
        // Uncompiled?
        schema.fields.forEach(function (field) {
          return _this10._pushProp(field.name);
        });
      } else if (schema.eachField) {
        schema.eachField(function (field) {
          if (!schema.isDefaultField(field.get('name'))) {
            _this10._pushProp(field.get('name'));
          }
        });
      }
    }
  }, {
    key: "_setMuteEvents",
    value: function _setMuteEvents(muteCreate) {
      this._set('muteCreate', muteCreate);
    }
  }, {
    key: "set",
    value: function set(props) {
      if ((0, _typeof2.default)(props) !== 'object') {
        throw new Error('props must be an object');
      }

      if (props.schema !== undefined) {
        this._setSchema(props.schema);
      }

      if (props.name !== undefined) {
        this._setName(props.name);
      }

      if (props.parent !== undefined) {
        this._setParent(props.parent);
      }

      if (props.isStore !== undefined) {
        this._setIsStore(props.isStore);
      }

      if (props.muteCreate !== undefined) {
        this._setMuteEvents(props.muteCreate);
      }

      this._setProps(Object.assign({}, props, {
        component: undefined,
        props: undefined,
        schema: undefined,
        name: undefined,
        parent: undefined,
        isStore: undefined,
        listeners: undefined,
        muteCreate: undefined
      })); // The listeners are set after _setProps because sub event listeners depend on other properties


      if (props.listeners !== undefined) {
        this._setListeners(props.listeners);
      }
    }
  }, {
    key: "_getProperty",
    value: function _getProperty(name) {
      return this['_' + name];
    }
  }, {
    key: "_getIfDefined",
    value: function _getIfDefined(name) {
      this._throwIfNotDefined(name);

      return this._getProperty(name);
    }
  }, {
    key: "_get",
    value: function _get(name) {
      if (this._hasDot(name)) {
        // Using dot notation
        var _this$_getSubProperty3 = this._getSubProperty(name),
            property = _this$_getSubProperty3.property;

        return property;
      } else {
        // Not using dot notation
        return this._getIfDefined(name);
      }
    }
  }, {
    key: "getOne",
    value: function getOne(name) {
      return this._get(name);
    }
  }, {
    key: "get",
    value: function get(names) {
      var _this11 = this;

      if (!names) {
        // Get a list of all the property names
        names = this._propNames;
      }

      if (Array.isArray(names)) {
        // Get multiple props
        var values = {};
        names.forEach(function (name) {
          values[name] = _this11.getOne(name);
        });
        return values;
      } else {
        // Get single prop
        return this.getOne(names);
      }
    }
  }, {
    key: "getClassName",
    value: function getClassName() {
      // Note: we cannot use Class.prototype.name as this is overwritten by minifiers like UglifyJS.
      //
      // The compiler now uses Object.defineProperty to dynamically set the class name
      // if (this._className) {
      //   // The component was generated via MSON and so the contructor.name is inaccurate
      //   return this._className;
      // } else {
      //   return this.constructor.name;
      // }
      //
      return this._className;
    }
  }, {
    key: "getParentClassName",
    value: function getParentClassName() {
      // Note: we cannot use Class.prototype.name as this is overwritten by minifiers like UglifyJS.
      var Parent = Object.getPrototypeOf(this.constructor);
      var parent = new Parent();
      return parent.getClassName();
    }
  }, {
    key: "_cloneDeep",
    value: function _cloneDeep(obj) {
      return (0, _cloneDeepWith.default)(obj, function (item, index, obj, stack) {
        if (index === '_parent' || index === 'parent') {
          // We don't clone any parent data as this data is circular. This check greatly speeds up
          // cloning as otherwise cloneDeepWith has to auto detect circular references, which can be
          // slow. "_parent" can be present when component.set({ parent }) is called and "parent" can
          // be present in the fillerProps of an action.
          return item;
        }
      });
    }
  }, {
    key: "_cloneSlow",
    value: function _cloneSlow() {
      var clonedComponent = this._cloneDeep(this);

      clonedComponent._setDebugId();

      clonedComponent._setKey(); // Remove all listeners and expect new ones to be set up so that we don't have duplicate
      // listeners


      clonedComponent.removeAllListeners(); // We have to manually emitCreate as otherwise the cloned component may not emit didCreate. This
      // can occur when a component is cloned before didCreate is emitted.

      clonedComponent._emitCreateIfNotMuted();

      return clonedComponent;
    }
  }, {
    key: "_cloneFast",
    value: function _cloneFast(_ref2) {
      var defaultProps = _ref2.defaultProps,
          excludeProps = _ref2.excludeProps;

      // _cloneFast is almost 10 times faster than _cloneSlow. It is far faster to instantiate a new
      // component, deep clone some props and then set the props on the new component.
      var Component = this._registrar.compiler.getCompiledComponent(this.getClassName());

      var clonedComponent = new Component(defaultProps);
      var excludePropsByDefault = ['parent'];

      if (excludeProps) {
        excludeProps = excludeProps.concat(excludePropsByDefault);
      }

      var names = (0, _difference.default)(this._propNames, excludeProps); // Note: using JSON stringify+parse may be slightly faster than cloneDeep, but cloneDeep can
      // handle circular references.

      clonedComponent.set(this._cloneDeep(this.get(names))); // The names don't include the parent. The parent should not be deep cloned.

      clonedComponent.set(this.get(['parent']));
      return clonedComponent;
    }
  }, {
    key: "_canCloneFast",
    value: function _canCloneFast() {
      return this._registrar.compiler && this._registrar.compiler.exists(this.getClassName());
    }
  }, {
    key: "_clone",
    value: function _clone() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          defaultProps = _ref3.defaultProps,
          excludeProps = _ref3.excludeProps;

      if (this._canCloneFast()) {
        return this._cloneFast({
          defaultProps: defaultProps,
          excludeProps: excludeProps
        });
      } else {
        return this._cloneSlow();
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return this._clone();
    } // This should be called whenever the route changes and the component is loaded

  }, {
    key: "emitLoad",
    value: function emitLoad() {
      this.emitChange('load');

      if (!this._hasListenerForEvent('load')) {
        // There are no load listeners so emit a loaded event
        this._emitDidLoad();
      }
    } // This should be called whenever the route changes and the component is unloaded

  }, {
    key: "emitUnload",
    value: function emitUnload() {
      // Flag needs to be set before unload event is emitted or else listeners may not read
      // isLoaded=false
      this._isLoaded = false;
      this.emitChange('unload');
    }
  }, {
    key: "_bubbleUpEvents",
    value: function _bubbleUpEvents(component, events) {
      var _this12 = this;

      events.forEach(function (event) {
        component.on(event, function (value) {
          _this12.emitChange(event, value);
        });
      });
    }
  }, {
    key: "getKey",
    value: function getKey() {
      return this._key;
    } // Set properties on another component. Useful for nested components

  }, {
    key: "_setOn",
    value: function _setOn(component, props, propNames) {
      propNames.forEach(function (name) {
        if (props[name] !== undefined) {
          component.set((0, _defineProperty2.default)({}, name, props[name]));
        }
      });
    } // Get properties from another component. Useful for nested components

  }, {
    key: "_getFrom",
    value: function _getFrom(component, name, propNames) {
      if (propNames.indexOf(name) !== -1) {
        return component.get(name);
      }
    }
  }, {
    key: "buildSchemaForm",
    value: function buildSchemaForm(form, compiler) {
      var schemas = this.get('schema');
      schemas.forEach(function (schema) {
        if (!compiler.isCompiled(schema)) {
          schema = compiler.newComponent(schema);
        }

        form.copyFields(schema);
      });
    }
  }, {
    key: "getUniqueId",
    value: function getUniqueId() {
      return this.constructor.toUniqueId(this._key);
    }
  }, {
    key: "isLoaded",
    value: function isLoaded() {
      return this._isLoaded;
    }
  }, {
    key: "resolveAfterCreate",
    value: function resolveAfterCreate() {
      return this._resolveAfterCreate;
    }
  }, {
    key: "resolveAfterLoad",
    value: function resolveAfterLoad() {
      return this._resolveAfterLoad;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.removeAllListeners();
    }
  }, {
    key: "getHiddenFieldDefinitions",
    value: function getHiddenFieldDefinitions(names) {
      return names.map(function (name) {
        return {
          name: name,
          component: 'Field',
          hidden: true
        };
      });
    }
  }], [{
    key: "getLayer",
    value: function getLayer() {
      return this.constructor._layer;
    }
  }, {
    key: "setLayer",
    value: function setLayer(layer) {
      this.constructor._layer = layer;
    }
  }, {
    key: "getNextKey",
    value: function getNextKey() {
      return _getNextKey();
    }
  }, {
    key: "toUniqueId",
    value: function toUniqueId(key) {
      return 'mson-' + key;
    }
  }, {
    key: "getNextUniqueId",
    value: function getNextUniqueId() {
      var key = this.getNextKey();
      return this.toUniqueId(key);
    }
  }]);
  return BaseComponent;
}(_events2.default.EventEmitter);

exports.default = BaseComponent;
(0, _defineProperty2.default)(BaseComponent, "_layer", null);