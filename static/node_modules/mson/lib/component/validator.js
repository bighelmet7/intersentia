"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _each = _interopRequireDefault(require("lodash/each"));

var _cloneDeep = _interopRequireDefault(require("lodash/cloneDeep"));

var _sift = _interopRequireDefault(require("sift"));

var _propFiller = _interopRequireDefault(require("../compiler/prop-filler"));

var _queryToProps = _interopRequireDefault(require("../component/query-to-props"));

var Validator =
/*#__PURE__*/
function () {
  function Validator(props) {
    (0, _classCallCheck2.default)(this, Validator);
    this._props = props;
    this._propFiller = new _propFiller.default(props);
  }

  (0, _createClass2.default)(Validator, [{
    key: "_fillProps",
    value: function _fillProps(str) {
      return this._propFiller.fillString(str);
    } // Performs in place fill to prepare for sift query

  }, {
    key: "_fillWhere",
    value: function _fillWhere(where) {
      var _this = this;

      (0, _each.default)(where, function (node, name) {
        // Leaf node?
        if (typeof node === 'string') {
          where[name] = _this._fillProps(node);
        } else {
          // Recursively process node
          _this._fillWhere(node);
        }
      });
    }
  }, {
    key: "_fillErrorProps",
    value: function _fillErrorProps(error) {
      if (typeof error === 'string') {
        return this._fillProps(error);
      } else {
        error.error = this._fillProps(error.error);
        return error;
      }
    }
  }, {
    key: "_getWhereProps",
    value: function _getWhereProps(where) {
      // queryToProps() resolves all the properties in the query. This allows us to dynamically query
      // data in deeply nested components.
      return (0, _queryToProps.default)(where, this._props);
    }
  }, {
    key: "_validateWithRule",
    value: function _validateWithRule(rule) {
      // Clone where as we will be modifying the leaf nodes
      var where = (0, _cloneDeep.default)(rule.where); // Fill the props

      this._fillWhere(where); // Resolve the properties targeted in our filter


      var whereProps = this._getWhereProps(where); // Validation failed?


      var sifted = (0, _sift.default)(where, [whereProps]);

      if (sifted.length > 0) {
        return this._fillErrorProps(rule.error);
      }
    }
  }, {
    key: "validate",
    value: function validate(rules, all) {
      var errors = [];

      for (var i = 0; i < rules.length; i++) {
        var error = this._validateWithRule(rules[i]);

        if (error !== undefined) {
          errors.push(error); // Do we only want the first error?

          if (!all) {
            break;
          }
        }
      }

      return errors;
    }
  }]);
  return Validator;
}();

exports.default = Validator;