"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _baseComponent = _interopRequireDefault(require("./base-component"));

var _utils = _interopRequireDefault(require("../utils"));

// Used to create a component that can be dynamically defined on demand. WrappedComponent
// essentially exposes componentToWrap, which means that mutating the wrapped component mutates
// componentToWrap.
var WrappedComponent =
/*#__PURE__*/
function (_BaseComponent) {
  (0, _inherits2.default)(WrappedComponent, _BaseComponent);

  function WrappedComponent() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, WrappedComponent);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(WrappedComponent)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_className", 'WrappedComponent');
    return _this;
  }

  (0, _createClass2.default)(WrappedComponent, [{
    key: "_getWrappedComponentSchema",
    value: function _getWrappedComponentSchema() {
      return {
        component: 'Form',
        fields: [{
          name: 'componentToWrap',
          component: 'Field'
        }]
      };
    }
  }, {
    key: "_create",
    value: function _create(props) {
      (0, _get2.default)((0, _getPrototypeOf3.default)(WrappedComponent.prototype), "_create", this).call(this, props);
      this._preserveClassName = true;
      this.set({
        schema: this._getWrappedComponentSchema()
      });

      if (props.componentToWrap !== undefined) {
        this.setComponentToWrap(props.componentToWrap);
      }
    }
  }, {
    key: "setComponentToWrap",
    value: function setComponentToWrap(componentToWrap) {
      // Is componentToWrap a string? This will happen when componentToWrap is a template parameter,
      // e.g. {{baseForm}}, and we are validating the component definition and don't have an instance
      // to inject
      if (typeof componentToWrap !== 'string') {
        this._componentToWrap = componentToWrap;

        this._wrapComponent();
      }
    }
  }, {
    key: "_getAllMethodOrFunctionNames",
    value: function _getAllMethodOrFunctionNames() {
      // componentToWrap can either be a class or object or functions and in each case we need a
      // different way of identifying the function/method names. In particular when wrapping a
      // component, _wrapComponent will result in wrapping the methods as functions.
      var names = _utils.default.getAllMethodNames(this._componentToWrap);

      return names.concat(_utils.default.getAllFunctionNames(this._componentToWrap));
    }
  }, {
    key: "_wrapComponent",
    value: function _wrapComponent() {
      var _this2 = this;

      var names = this._getAllMethodOrFunctionNames();

      names.forEach(function (name) {
        // Skip system function names
        if (['caller', 'callee', 'arguments', 'constructor'].indexOf(name) === -1 && name.indexOf('__') === -1) {
          var property = _this2._componentToWrap[name];

          if (_this2._componentToWrap[name]) {
            _this2[name] = function () {
              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }

              return property.apply(_this2._componentToWrap, args);
            };
          }
        }
      });

      if (this._preserveClassName) {
        // Preserve the original className
        //
        // Note: we cannot use Class.prototype.name as this is overwritten by minifiers like UglifyJS.
        //
        // Object.defineProperty(this._componentToWrap.constructor, 'name', {
        //   value: thisClassName,
        //   writable: false
        // });
        //
        this.getClassName = this._componentToWrap.getClassName.bind(this);
      }
    }
  }]);
  return WrappedComponent;
}(_baseComponent.default);

exports.default = WrappedComponent;