"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _compiler = _interopRequireDefault(require("./compiler"));

var _form = _interopRequireDefault(require("./form"));

var _utils = _interopRequireDefault(require("./utils"));

// TODO: move to ../test and rename to just utils.js
var TestUtils =
/*#__PURE__*/
function () {
  function TestUtils() {
    (0, _classCallCheck2.default)(this, TestUtils);
    (0, _defineProperty2.default)(this, "defaultFields", ['id', 'userId', 'createdAt', 'updatedAt', 'archivedAt', 'order']);
  }

  (0, _createClass2.default)(TestUtils, [{
    key: "toDefaultFieldsObject",
    value: function toDefaultFieldsObject(value) {
      var obj = {};
      this.defaultFields.forEach(function (name) {
        return obj[name] = value;
      });
      return obj;
    }
  }, {
    key: "once",
    value: function once(emitter, evnt) {
      return _utils.default.once(emitter, evnt);
    }
  }, {
    key: "timeout",
    value: function timeout(ms) {
      return new Promise(function (resolve) {
        setTimeout(resolve, ms);
      });
    } // TODO: refactor to use await/async

  }, {
    key: "waitFor",
    value: function waitFor(poll, maxSleep, sleepMs) {
      var totalSleep = 0;
      maxSleep = maxSleep ? maxSleep : 5000;
      sleepMs = sleepMs ? sleepMs : 100;
      return new Promise(function (resolve, reject) {
        var waitFor = function waitFor() {
          // Wrap in promise so that waitMore doesn't have to be a promise
          return Promise.resolve().then(function () {
            return poll();
          }).then(function (obj) {
            if (typeof obj === 'undefined') {
              if (totalSleep >= maxSleep) {
                reject(new Error('waited for ' + totalSleep + ' ms'));
              } else {
                totalSleep += sleepMs;
                setTimeout(waitFor, sleepMs);
              }
            } else {
              resolve(obj);
            }
          });
        };

        waitFor();
      });
    }
  }, {
    key: "_expectValuesToHaveErr",
    value: function _expectValuesToHaveErr(field, values, haveErr, err) {
      values.forEach(function (value) {
        field.clearErr();
        field.setValue(value);
        field.validate(); // Use object in expect so that errors are easy to immediately see

        expect({
          value: value,
          hasErr: field.hasErr()
        }).toEqual({
          value: value,
          hasErr: haveErr
        });

        if (err) {
          expect(field.getErr()).toEqual(err);
        }
      });
    }
  }, {
    key: "expectValuesToBeValid",
    value: function expectValuesToBeValid(field, validValues) {
      this._expectValuesToHaveErr(field, validValues, false);
    }
  }, {
    key: "expectValuesToBeInvalid",
    value: function expectValuesToBeInvalid(field, invalidValues, err) {
      this._expectValuesToHaveErr(field, invalidValues, true, err);
    }
  }, {
    key: "expectSchemaToBeValid",
    value: function expectSchemaToBeValid(component, values) {
      var schemaForm = new _form.default();
      component.buildSchemaForm(schemaForm, _compiler.default);
      schemaForm.setValues(values);
      schemaForm.validate();
      expect(schemaForm.hasErr()).toEqual(false);
    } // Note: this doesn't appear to work so we use the implementation below
    // async expectToFinishBefore(promiseFactory, milliseconds) {
    //   const timer = async () => {
    //     await testUtils.timeout(milliseconds);
    //     throw new Error('took more than ' + milliseconds + ' milliseconds');
    //   }
    //   return Promise.race([timer(), promiseFactory()])
    // }
    // Note: the built in timeout per test in jest doesn't appear to work so here is a custom routine.

  }, {
    key: "expectToFinishBefore",
    value: function () {
      var _expectToFinishBefore = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(promiseFactory, milliseconds) {
        var begin;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                begin = new Date();
                _context.next = 3;
                return promiseFactory();

              case 3:
                if (!(new Date().getTime() - begin.getTime() > milliseconds)) {
                  _context.next = 5;
                  break;
                }

                throw new Error('took more than ' + milliseconds + ' milliseconds');

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function expectToFinishBefore(_x, _x2) {
        return _expectToFinishBefore.apply(this, arguments);
      }

      return expectToFinishBefore;
    }() // TODO: I don't think async testing with jest is working properly
    // (https://facebook.github.io/jest/docs/en/expect.html#rejects). When it does, refactor out this
    // helper fn

  }, {
    key: "expectToThrow",
    value: function () {
      var _expectToThrow = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2(promiseFactory, errorNameOrError, errorMessage) {
        var err;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                err = {
                  name: 'NoError'
                };
                _context2.prev = 1;
                _context2.next = 4;
                return promiseFactory();

              case 4:
                _context2.next = 9;
                break;

              case 6:
                _context2.prev = 6;
                _context2.t0 = _context2["catch"](1);
                err = _context2.t0;

              case 9:
                if (errorNameOrError) {
                  if (typeof errorNameOrError === 'string') {
                    expect(err.name).toEqual(errorNameOrError);
                  } else {
                    expect(err).toEqual(errorNameOrError);
                  }
                }

                if (errorMessage) {
                  expect(err.message).toEqual(errorMessage);
                }

                return _context2.abrupt("return", err);

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[1, 6]]);
      }));

      function expectToThrow(_x3, _x4, _x5) {
        return _expectToThrow.apply(this, arguments);
      }

      return expectToThrow;
    }()
  }, {
    key: "sleepToEnsureDifferentTimestamps",
    value: function () {
      var _sleepToEnsureDifferentTimestamps = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3() {
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", this.timeout(2));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function sleepToEnsureDifferentTimestamps() {
        return _sleepToEnsureDifferentTimestamps.apply(this, arguments);
      }

      return sleepToEnsureDifferentTimestamps;
    }()
  }]);
  return TestUtils;
}();

var _default = new TestUtils();

exports.default = _default;