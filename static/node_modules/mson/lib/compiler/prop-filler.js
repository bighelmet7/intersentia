"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _cloneDeepWith = _interopRequireDefault(require("lodash/cloneDeepWith"));

// TODO: move from compiler directory as used by multiple modules
var PropFiller =
/*#__PURE__*/
function () {
  function PropFiller(props) {
    (0, _classCallCheck2.default)(this, PropFiller);
    this.setProps(props);
  }

  (0, _createClass2.default)(PropFiller, [{
    key: "setProps",
    value: function setProps(props) {
      this._props = props;
    }
  }, {
    key: "_getTemplateName",
    value: function _getTemplateName(str) {
      // Note: we use a format like {{name}} instead of ${name} as some linters report errors when
      // template strings are found in regular strings.
      var matches = str.match(/^{{([^{]*)}}$/);

      if (matches) {
        return matches[1];
      }
    }
  }, {
    key: "_getPropFromObj",
    value: function _getPropFromObj(obj, name) {
      try {
        var names = name.split('.');
        var nestedObj; // Getter?

        if (obj.get && typeof obj.get === 'function') {
          nestedObj = obj.get(names[0]);
        } else {
          nestedObj = obj[names[0]];
        }

        if (names.length > 1) {
          names.shift(); // remove 1st name

          return this._getPropFromObj(nestedObj, names.join('.'));
        } else {
          return nestedObj;
        }
      } catch (err) {
        // This can occur when there is no nested value in props
        return undefined;
      }
    }
  }, {
    key: "_getProp",
    value: function _getProp(name) {
      return this._getPropFromObj(this._props, name);
    } // We leave the original template parameter strings intact if there isn't a match as the template
    // parameter may match at a secondary layer, e.g. the template parameter is not for the MSON
    // object, but in a validator.

  }, {
    key: "_getPropOrOriginalString",
    value: function _getPropOrOriginalString(name, str) {
      var value = this._getProp(name);

      return value === undefined ? str : value;
    }
  }, {
    key: "fillString",
    value: function fillString(obj) {
      var _this = this;

      // Is obj a string?
      if (typeof obj === 'string') {
        // Is the string just a template string?
        var name = this._getTemplateName(obj);

        if (name !== undefined) {
          // Replace with the raw prop so that numbers are not converted to strings by replace()
          return this._getPropOrOriginalString(name, obj);
        } else {
          return obj.replace(/{{([^{]*)}}/g, function (match, name) {
            return _this._getPropOrOriginalString(name, match);
          });
        }
      } else {
        // We only fill strings so just return the original object
        return obj;
      }
    }
  }, {
    key: "fillAll",
    value: function fillAll(items) {
      var _this2 = this;

      // Recursively dive into objects and fill any strings
      return (0, _cloneDeepWith.default)(items, function (item) {
        if (item && item._className) {
          // The item is a component, therefore we should not clone it. TODO: is there a better way to
          // determine this?
          return item;
        } else if (typeof item === 'string') {
          return _this2.fillString(item);
        }
      });
    }
  }, {
    key: "fill",
    value: function fill(obj) {
      if (typeof obj === 'string') {
        return this.fillString(obj);
      } else {
        return this.fillAll(obj);
      }
    }
  }]);
  return PropFiller;
}();

exports.default = PropFiller;