"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Compiler = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _components = _interopRequireDefault(require("../components"));

var _propFiller = _interopRequireDefault(require("./prop-filler"));

var _registrar = _interopRequireDefault(require("./registrar"));

var _each = _interopRequireDefault(require("lodash/each"));

var _cloneDeep = _interopRequireDefault(require("lodash/cloneDeep"));

// Notes:
//  - An older design did a one-time build of MSON components and then stored them in
//    _compiledComponents, unfortunately, this optimization had to be removed as MSON components can
//    now have dynamic attributes. TODO: as a future optimization we can check to see if a MSON
//    component has dynamic attributes and if it doesn't then we can cache the compiled component.
//    But, is this caching even worth it? The downside to the caching is that we could end up
//    storing more in memory.
var Compiler =
/*#__PURE__*/
function () {
  function Compiler(props) {
    (0, _classCallCheck2.default)(this, Compiler);
    this._components = props.components;
    this._validateOnly = false;
  }

  (0, _createClass2.default)(Compiler, [{
    key: "setValidateOnly",
    value: function setValidateOnly(validateOnly) {
      // The validateOnly mode allows us to validate a definition that contains dynamic components
      // without requiring these dynamic components to be instantiated. It essentially disables the
      // listeners and then just uses the schemas to validate the definition.
      this._validateOnly = validateOnly;
    } // // We keep this separate from components so that we have a way of referencing uncompiled
    // // components after the components have been compiled. Moreover, this construct doesn't require
    // // any special organization in the components object.
    // _compiledComponents = {};

  }, {
    key: "exists",
    value: function exists(name) {
      return !!this._components[name];
    }
  }, {
    key: "getComponent",
    value: function getComponent(name) {
      if (this.exists(name)) {
        return this._components[name];
      } else {
        throw new Error('missing component ' + name);
      }
    }
  }, {
    key: "_compileAnyFactoryProduct",
    value: function _compileAnyFactoryProduct(defaultProps) {
      var _this = this;

      // Note: we have to do this here, and not in Factory as we need to defer instantiation of
      // factory props until the factory produces. Otherwise, multiple calls to produce() can yield
      // components with shared memory.
      if (defaultProps.component === 'Factory') {
        var product = defaultProps.product;
        var properties = defaultProps.properties;
        delete defaultProps.properties;

        defaultProps.product = function () {
          var component = null;

          if (_this.isCompiled(product)) {
            // Component is a factory so call produce so that we can wrap the result
            component = product.produce();
          } else {
            // Note: we don't have to clone the product definition as this is done when calling
            // newComponent
            component = _this.newComponent(product);
          }

          if (properties) {
            // We need to clone the properties so that each product has its own instance
            var clonedProperties = (0, _cloneDeep.default)(properties);

            _this._instantiate(clonedProperties);

            component.set(clonedProperties);
          }

          return component;
        };
      }
    }
  }, {
    key: "_getWrappedComponentClass",
    value: function _getWrappedComponentClass(name, defaultProps, parentProps, className) {
      var Component = this.getCompiledComponent(name, defaultProps);

      if (this._validateOnly) {
        // We need to mute the events or else there may be listeners that will try to act on a dynamic
        // component that will never be supplied.
        defaultProps = Object.assign({}, defaultProps, {
          muteCreate: true,
          disableSubEvents: true
        });
      }

      var self = this; // Create a class that sets the props by default

      var MyComponent =
      /*#__PURE__*/
      function (_Component) {
        (0, _inherits2.default)(MyComponent, _Component);

        function MyComponent() {
          var _getPrototypeOf2;

          var _this2;

          (0, _classCallCheck2.default)(this, MyComponent);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this2 = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(MyComponent)).call.apply(_getPrototypeOf2, [this].concat(args)));
          (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), "_className", className === undefined ? name : className);
          return _this2;
        }

        (0, _createClass2.default)(MyComponent, [{
          key: "_create",
          value: function _create(props) {
            // Use the parentProps and props to fill
            var propFiller = new _propFiller.default(Object.assign({}, parentProps, props)); // Note: fillAll clones the data and this is needed as we will be instantiating pieces of
            // the data below and we want each instance of MyComponent to have its own copy

            defaultProps = propFiller.fillAll(defaultProps);

            self._compileAnyFactoryProduct(defaultProps); // Remove these properties as they are no longer needed


            delete defaultProps.component; // Instantiate defaultProps. We do this in _create() so that we have a fresh instance of all
            // the child components

            self._instantiate(defaultProps); // props may also contain items that need to be instantiated


            self._instantiate(props); // The default props and props need to be passed to _create() so that parent has a chance to
            // act on these props. E.G. componentToWrap needs to be set via _create() before any other
            // action is taken.


            var propsAndDefaultProps = Object.assign({}, defaultProps, props);
            (0, _get2.default)((0, _getPrototypeOf3.default)(MyComponent.prototype), "_create", this).call(this, propsAndDefaultProps); // Are we wrapping a component? Clear the componentToWrap

            if (defaultProps.componentToWrap) {
              delete defaultProps.componentToWrap;
            } // Set the defaultProps, which essentially customizes the component based on the
            // defaultProps. This would be similar to how you set properties in a
            // constructor()/_create() if you were to build the component in JS.


            this.set(defaultProps);
          }
        }]);
        return MyComponent;
      }(Component); // Note: we cannot use Class.prototype.name as this is overwritten by minifiers like UglifyJS.
      //
      // Object.defineProperty(MyComponent, 'name', {
      //   value: name,
      //   writable: false
      // });


      return MyComponent;
    } // Note: this function is VERY slow so we analyze obj.constructor.name instead
    // isCompiled(obj) {
    //   if (typeof obj === 'object') {
    //     let isCompiled = false;
    //     try {
    //       obj.constructor();
    //     } catch (err) {
    //       isCompiled = true;
    //     }
    //     return isCompiled;
    //   } else {
    //     return true;
    //   }
    // }

  }, {
    key: "isCompiled",
    value: function isCompiled(obj) {
      if ((0, _typeof2.default)(obj) === 'object') {
        return obj.constructor.name !== 'Object' && obj.constructor.name !== 'Array';
      } else {
        return true;
      }
    }
  }, {
    key: "getCompiledComponent",
    value: function getCompiledComponent(name, parentProps) {
      // TODO: use a cache to store compiled components so only have to compile once? Does this really
      // reduce overall latency? The downside is that more will be stored in the components object,
      // although not much more as it is just a wrapper.
      var Component = this.getComponent(name);

      if (this.isCompiled(Component)) {
        return Component;
      } else {
        // Note: we need to pass name to compile() so that the className is set properly
        return this.compile(Component, parentProps, name);
      }
    } // The parentProps define values for the template parameters in props and allow us to make pieces
    // of our components dynamic.

  }, {
    key: "compile",
    value: function compile(props, parentProps, className) {
      return this._getWrappedComponentClass(props.component, props, parentProps, className);
    }
  }, {
    key: "_instantiateComponent",
    value: function _instantiateComponent(Component, props) {
      return new Component(props);
    }
  }, {
    key: "_instantiate",
    value: function _instantiate(props) {
      var _this3 = this;

      // Already instantiated? This can occur with wrapped components.
      if (props instanceof _components.default.Component) {
        return props;
      }

      if (props.component === 'Factory') {
        // The definition is for a factory, wrap up the component and defer the instantiation of the
        // child props
        var Component = this.compile(props);
        return new Component();
      } // Descend all the way down the tree and then start instantiating on the way up


      (0, _each.default)(props, function (prop, name) {
        if ((0, _typeof2.default)(prop) === 'object' && prop !== null) {
          props[name] = _this3._instantiate(prop);
        }
      }); // Does the object need to be instantiated?

      if (props.component) {
        var _Component2 = this.getCompiledComponent(props.component);

        return this._instantiateComponent(_Component2, Object.assign({}, props, {
          component: undefined
        }));
      } else {
        return props;
      }
    }
  }, {
    key: "newComponent",
    value: function newComponent(props) {
      var Component = this.compile(props);
      return this._instantiateComponent(Component);
    }
  }, {
    key: "getOldestCompiledAncestor",
    value: function getOldestCompiledAncestor(name) {
      var component = this.getComponent(name);

      if (!this.isCompiled(component)) {
        // Ancestor is still an uncompiled component so go again
        return this.getOldestCompiledAncestor(component.component);
      } else {
        return name;
      }
    }
  }, {
    key: "registerComponent",
    value: function registerComponent(name, component) {
      // Reregistration is now allowed as it allows for things like hot reloading of changed
      // definitions.
      //
      // if (this._components[name]) {
      //   throw new Error(`component ${name} already exists`);
      // } else {
      this._components[name] = component; // }
    }
  }, {
    key: "registerComponents",
    value: function registerComponents(components) {
      var _this4 = this;

      (0, _each.default)(components, function (component) {
        return _this4.registerComponent(component.name, component);
      });
    }
  }, {
    key: "deregisterComponent",
    value: function deregisterComponent(name) {
      delete this._components[name];
    }
  }, {
    key: "createSchemaForm",
    value: function createSchemaForm(definition) {
      var component = this.newComponent({
        component: definition.component
      });
      var Form = this._components.Form;
      var schemaForm = new Form();
      component.buildSchemaForm(schemaForm, this); // Set the schema so that props can be set at the same layer as the schema

      if (definition.schema) {
        var topSchema = compiler.newComponent(definition.schema); // Not required as these values are defaults at the same layer as the schema

        topSchema.setRequired(false);
        schemaForm.copyFields(topSchema);
      }

      return schemaForm;
    }
  }, {
    key: "validateDefinition",
    value: function validateDefinition(definition) {
      var schemaForm = this.createSchemaForm(definition);
      schemaForm.setValues(definition);
      schemaForm.validate();
      return schemaForm;
    }
  }]);
  return Compiler;
}();

exports.Compiler = Compiler;
var compiler = new Compiler({
  components: _components.default
}); // Register compiler so that components have access to the compiler at run-time without causing a
// circular dependency

_registrar.default.compiler = compiler;
var _default = compiler;
exports.default = _default;