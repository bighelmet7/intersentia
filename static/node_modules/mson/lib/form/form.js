"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _component = _interopRequireDefault(require("../component"));

var _merge = _interopRequireDefault(require("lodash/merge"));

var _each = _interopRequireDefault(require("lodash/each"));

var _validator = _interopRequireDefault(require("../component/validator"));

var _mapa = _interopRequireDefault(require("../mapa"));

var _idField = _interopRequireDefault(require("../fields/id-field"));

var _numberField = _interopRequireDefault(require("../fields/number-field"));

var _dateField = _interopRequireDefault(require("../fields/date-field"));

var _buttonField = _interopRequireDefault(require("../fields/button-field"));

var _componentFillerProps = _interopRequireDefault(require("../component/component-filler-props"));

var _componentField = _interopRequireDefault(require("../fields/component-field"));

var _formField = _interopRequireDefault(require("../fields/form-field"));

var _formErr = _interopRequireDefault(require("./form-err"));

var _extendedField = _interopRequireDefault(require("../fields/extended-field"));

var Form =
/*#__PURE__*/
function (_Component) {
  (0, _inherits2.default)(Form, _Component);

  function Form() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, Form);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(Form)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_className", 'Form');
    return _this;
  }

  (0, _createClass2.default)(Form, [{
    key: "_formSetMSONSchema",
    value: function _formSetMSONSchema() {
      this.set({
        schema: {
          component: 'Form',
          fields: [{
            name: 'fields',
            component: 'CollectionField',
            // required: true,
            formFactory: {
              component: 'Factory',
              product: {
                component: 'SchemaValidatorForm'
              }
            }
          }, {
            // TODO: can't this be removed?
            name: 'form',
            component: 'Field'
          }, {
            name: 'validators',
            component: 'CollectionField',
            formFactory: {
              component: 'Factory',
              product: {
                component: 'ValidatorForm'
              }
            }
          }, {
            name: 'access',
            component: 'FormField',
            form: {
              component: 'AccessForm'
            }
          }, {
            name: 'indexes',
            component: 'Field' // component: 'CollectionField',
            // form: {
            //   // TODO: create and use IndexForm. Needs to verfiy that fields are present--see
            //   // SchemaValidatorForm for something similar.
            //   component: 'IndexForm'
            // }

          }, {
            name: 'touched',
            component: 'BooleanField'
          }, {
            name: 'err',
            component: 'Field'
          }, {
            name: 'dirty',
            component: 'BooleanField'
          }, {
            name: 'pristine',
            component: 'BooleanField'
          }, {
            name: 'autoValidate',
            component: 'BooleanField'
          }, {
            name: 'reportUndefined',
            component: 'BooleanField'
          }, {
            name: 'resetOnLoad',
            component: 'BooleanField'
          }, {
            name: 'showArchived',
            component: 'BooleanField'
          }, {
            name: 'searchString',
            component: 'TextField'
          }, {
            name: 'cursor',
            component: 'TextField'
          }, {
            name: 'snapshot',
            component: 'BooleanField'
          }, {
            name: 'mode',
            component: 'TextField'
          }, {
            name: 'isLoading',
            component: 'BooleanField'
          }, {
            name: 'omitDefaultFields',
            component: 'BooleanField'
          }, {
            name: 'value',
            component: 'Field'
          }, {
            name: 'clear',
            component: 'BooleanField'
          }, {
            name: 'reset',
            component: 'BooleanField'
          }, {
            name: 'fullWidth',
            component: 'BooleanField'
          }, {
            name: 'editable',
            component: 'BooleanField'
          }, {
            name: 'hidden',
            component: 'BooleanField'
          }, {
            name: 'required',
            component: 'BooleanField'
          }, {
            name: 'out',
            component: 'BooleanField'
          }, {
            name: 'disabled',
            component: 'BooleanField'
          }, {
            name: 'eachField',
            component: 'Field'
          }, {
            // Used to disable the submit action on the form so that when the user clicks a submit
            // button on a nested form, it doesn't also trigger a submit on the parent form. This
            // can occur when using type=submit when there are multiple forms.
            name: 'disableSubmit',
            component: 'BooleanField'
          }, {
            name: 'useDisplayValue',
            component: 'BooleanField'
          }, {
            name: 'change',
            component: 'Field'
          }, {
            name: 'clearErrs',
            component: 'BooleanField'
          }]
        }
      });
    }
  }, {
    key: "_create",
    value: function _create(props) {
      (0, _get2.default)((0, _getPrototypeOf3.default)(Form.prototype), "_create", this).call(this, props);
      this._componentFillerProps = new _componentFillerProps.default();
      this._fields = new _mapa.default();
      this._defaultFields = new _mapa.default();
      this._validators = [];

      this._clearExtraErrors();

      if (!props || !props.omitDefaultFields) {
        this._addDefaultFields();

        this._createDefaultFields();
      }

      this._formSetMSONSchema();

      this._setDefaults(props, {
        // We default this to false as otherwise there is a lot of extra overhead incurred whenever we
        // set a value-especially when setting values at the top-most component.
        autoValidate: false,
        // Whether or not to report errors when an undefined (extra) field is specified
        reportUndefined: true,
        // If true, the form is reset on load
        resetOnLoad: true,
        // Only show non-archived
        showArchived: false
      });

      this._listenForLoad();

      this._listenForUnload();

      this._listenForShowArchived();

      this._listenForSearchString();

      this._listenForScroll();
    }
  }, {
    key: "_setSubmitDisabled",
    value: function _setSubmitDisabled(disabled) {
      var button = this._getSubmitButton();

      if (button) {
        button.set({
          disabled: disabled
        });
      }
    }
  }, {
    key: "_handleLoadFactory",
    value: function _handleLoadFactory() {
      var _this2 = this;

      return function () {
        if (_this2.get('resetOnLoad')) {
          // Clear any previous values
          _this2.reset();
        } // Note: this is probably more trouble than its worth as when the user is first filling in the
        // form there are no errors until a field is touched and in turn it is probably best to
        // provide the user with something to click that will give them feedback about the error.
        //
        // // Disable submit buttons by default
        // this._setSubmitDisabled(true);
        // Pass load event down to fields


        _this2._fields.each(function (field) {
          return field.emitLoad();
        });
      };
    }
  }, {
    key: "_listenForLoad",
    value: function _listenForLoad() {
      this.on('load', this._handleLoadFactory());
    }
  }, {
    key: "_listenForUnload",
    value: function _listenForUnload() {
      var _this3 = this;

      this.on('unload', function () {
        // Revert to some defaults
        _this3.set({
          showArchived: false,
          searchString: null
        }); // Pass unload event down to fields


        _this3._fields.each(function (field) {
          return field.emitUnload();
        });
      });
    }
  }, {
    key: "_handleShowArchivedFactory",
    value: function _handleShowArchivedFactory() {
      var _this4 = this;

      return function (showArchived) {
        // Pass event down to fields
        _this4._fields.each(function (field) {
          return field.set({
            showArchived: showArchived
          });
        });
      };
    }
  }, {
    key: "_listenForShowArchived",
    value: function _listenForShowArchived() {
      this.on('showArchived', this._handleShowArchivedFactory());
    }
  }, {
    key: "_handleSearchStringFactory",
    value: function _handleSearchStringFactory() {
      var _this5 = this;

      return function (searchString) {
        // Pass event down to fields
        _this5._fields.each(function (field) {
          return field.set({
            searchString: searchString
          });
        });
      };
    }
  }, {
    key: "_listenForSearchString",
    value: function _listenForSearchString() {
      this.on('searchString', this._handleSearchStringFactory());
    }
  }, {
    key: "_handleScrollFactory",
    value: function _handleScrollFactory() {
      var _this6 = this;

      return function (e) {
        // Pass scroll event down to fields
        //
        // TODO: why isn't the following working?
        // this._fields.each(field => field.emit('scroll', e));
        _this6._fields.each(function (field) {
          field.emit('scroll', e);
        });
      };
    }
  }, {
    key: "_listenForScroll",
    value: function _listenForScroll() {
      this.on('scroll', this._handleScrollFactory());
    }
  }, {
    key: "isDefaultField",
    value: function isDefaultField(fieldName) {
      return this._defaultFields.has(fieldName);
    }
  }, {
    key: "_addDefaultFields",
    value: function _addDefaultFields() {
      // Default fields are hidden by default but accompany the form and allow for special
      // functionality, e.g. whether an archived form should be displayed. These fields exist as
      // fields and not properties on the form as this allows us to override the display of things
      // like creation dates. Moreover, default fields allow for the automatic formatting of things
      // like dates for stores like Firebase, which would otherwise destroy the formatting of our
      // dates.
      this._defaultFields.set('id', new _idField.default({
        name: 'id',
        label: 'Id',
        hidden: true
      }));

      this._defaultFields.set('userId', new _idField.default({
        name: 'userId',
        label: 'User Id',
        hidden: true
      }));

      this._defaultFields.set('createdAt', new _dateField.default({
        name: 'createdAt',
        label: 'Created At',
        hidden: true
      }));

      this._defaultFields.set('updatedAt', new _dateField.default({
        name: 'updatedAt',
        label: 'Updated At',
        hidden: true
      }));

      this._defaultFields.set('archivedAt', new _dateField.default({
        name: 'archivedAt',
        label: 'Archived At',
        hidden: true
      }));

      this._defaultFields.set('order', new _numberField.default({
        name: 'order',
        label: 'Order',
        hidden: true
      }));
    }
  }, {
    key: "_createDefaultFields",
    value: function _createDefaultFields() {
      var _this7 = this;

      this._defaultFields.each(function (field) {
        return _this7.addField(field);
      });
    }
  }, {
    key: "copyFields",
    value: function copyFields(form, clone) {
      var _this8 = this;

      var fields = [];

      form._fields.each(function (field) {
        if (!_this8.isDefaultField(field.get('name'))) {
          _this8.addField(clone ? field.clone() : field);

          fields.push(field);
        }
      });

      this._emitChangeToFields(fields);
    }
  }, {
    key: "cloneFields",
    value: function cloneFields(form) {
      this.copyFields(form, true);
    }
  }, {
    key: "elevate",
    value: function elevate(form) {
      this.copyFields(form);
      this.set({
        validators: form.get('validators'),
        listeners: form.get('listeners')
      });
    }
  }, {
    key: "_clearExtraErrors",
    value: function _clearExtraErrors() {
      this._extraErrors = [];
    }
  }, {
    key: "_setAccess",
    value: function _setAccess(access) {
      // Merge access recursively
      this._set('access', (0, _merge.default)(this._access, access));
    }
  }, {
    key: "_emitChangeToFields",
    value: function _emitChangeToFields(change) {
      // Emit change so that UI is notified
      this.set({
        change: change
      });
    }
  }, {
    key: "set",
    value: function set(props) {
      var _this9 = this;

      // Add fields before calling super.set so that listeners are added after the fields
      if (props.fields !== undefined) {
        props.fields.forEach(function (field) {
          _this9.addField(field);
        });

        this._emitChangeToFields(props.fields);
      }

      (0, _get2.default)((0, _getPrototypeOf3.default)(Form.prototype), "set", this).call(this, Object.assign({}, props, {
        fields: undefined,
        validators: undefined,
        access: undefined,
        value: undefined,
        clear: undefined,
        reset: undefined,
        fullWidth: undefined,
        // editable: undefined, // TODO: should other props be removed as well?
        hidden: undefined,
        required: undefined,
        out: undefined,
        disabled: undefined,
        setForEachField: undefined,
        useDisplayValue: undefined
      }));

      if (props.validators !== undefined) {
        this._validators = [];
        props.validators.forEach(function (validator) {
          _this9.addValidator(validator);
        });
      }

      if (props.value !== undefined) {
        this.setValues(props.value);
      }

      if (props.required !== undefined) {
        this.setRequired(props.required);
      }

      if (props.disabled !== undefined) {
        this.setDisabled(props.disabled);
      }

      if (props.editable !== undefined) {
        this.setEditable(props.editable);
      }

      if (props.hidden !== undefined) {
        this.setHidden(props.hidden);
      }

      if (props.out !== undefined) {
        this.setOut(props.out);
      }

      if (props.snapshot !== undefined) {
        this.setSnapshot(props.snapshot);
      }

      if (props.clear === true) {
        this.clearValues();
      }

      if (props.reset === true) {
        this.reset();
      } // The pristine prop allows us to set the dirty prop for the form and all its fields. We keep
      // this separate from the dirty prop so that we can listen for dirty events on the fields and
      // change the dirty state without triggering an infinite loop.


      if (props.pristine !== undefined) {
        this.setDirty(!props.pristine);
      }

      if (props.err !== undefined) {
        this._emitCanOrCannotSubmit();
      }

      if (props.access !== undefined) {
        this._setAccess(props.access);
      }

      if (props.fullWidth !== undefined) {
        this._setFullWidth(props.fullWidth);
      }

      if (props.eachField !== undefined) {
        this.setForEachField(props.eachField);
      }

      if (props.useDisplayValue !== undefined) {
        this.setUseDisplayValue(props.useDisplayValue);
      }

      if (props.clearErrs === true) {
        this.clearErrs();
      }
    }
  }, {
    key: "_setField",
    value: function _setField(field) {
      // Make sure the before field is present
      var before = field.get('before');
      var beforeName = before && this.hasField(before) ? before : undefined; // Make sure the after field is present

      var after = field.get('after');
      var afterName = after && this.hasField(after) ? after : undefined;

      this._fields.set(field.get('name'), field, beforeName, afterName);
    }
  }, {
    key: "_handleFieldTouchedFactory",
    value: function _handleFieldTouchedFactory() {
      var _this10 = this;

      return function (touched) {
        if (touched) {
          _this10.set({
            touched: true
          });
        }

        if (_this10.get('autoValidate')) {
          _this10.validate();
        }
      };
    }
  }, {
    key: "_addField",
    value: function _addField(field) {
      var _this11 = this;

      this._setField(field); // TODO: need to consider that field already exists. Also need to worry about cleaning up any
      // existing listeners when this happens?


      field.on('value', function (fieldValue) {
        // We use _setProperty() as if we used set() then we would trigger an infinite loop
        var value = _this11._value ? _this11._value : {};
        value[field.get('name')] = fieldValue;

        _this11._setProperty('value', value); // Doesn't trigger event


        _this11.emitChange('value', value);

        if (_this11.get('autoValidate')) {
          _this11.validate();
        }
      });
      field.on('touched', this._handleFieldTouchedFactory());
      field.on('err', function (err) {
        if (err) {
          _this11.set({
            err: true
          });
        }
      });
      field.on('dirty', function (dirty) {
        if (dirty) {
          _this11.set({
            dirty: true
          });
        }
      });
      field.on('click', function () {
        _this11.emitChange(field.get('name'));
      });
      field.set({
        parent: this
      });
    }
  }, {
    key: "addField",
    value: function addField(field) {
      // Not a field? We have to use the existence of isField instead of `instanceof Field` as a
      // wrapped field, e.g. a MSONComponent will fail the instanceof test, but is still a field.
      if (!field.isField) {
        if (this.isComponent(field)) {
          // Wrap the component in a ComponentField so that we can use any component in the form
          field = new _componentField.default({
            name: field.get('name'),
            content: field
          });
        } else {
          field = new _extendedField.default({
            name: field.name,
            properties: Object.assign({}, field, {
              name: undefined
            })
          });
        }
      }

      if (field instanceof _extendedField.default && this.hasField(field.get('name'))) {
        this.getField(field.get('name')).set(field.get('properties'));
        return;
      }

      if (field instanceof _formField.default && field.get('elevate')) {
        this.elevate(field.get('form'));
      } else {
        this._addField(field);
      }
    }
  }, {
    key: "removeField",
    value: function removeField(name) {
      var field = this.getField(name);

      this._fields.delete(name); // Prevent a listener leak


      field.destroy();
    }
  }, {
    key: "removeFieldsExcept",
    value: function removeFieldsExcept(names) {
      var _this12 = this;

      this._fields.each(function (field, name) {
        if (names === undefined || names.indexOf(name) === -1) {
          _this12.removeField(name);
        }
      });
    }
  }, {
    key: "removeBlankFields",
    value: function removeBlankFields() {
      var _this13 = this;

      this._fields.each(function (field, name) {
        if (field.isBlank()) {
          _this13.removeField(name);
        }
      });
    }
  }, {
    key: "getOne",
    value: function getOne(name) {
      if (name === 'value') {
        return this.getValues();
      }

      return (0, _get2.default)((0, _getPrototypeOf3.default)(Form.prototype), "getOne", this).call(this, name);
    }
  }, {
    key: "getField",
    value: function getField(name) {
      try {
        return this._fields.get(name);
      } catch (err) {
        throw new Error('missing field ' + name);
      }
    }
  }, {
    key: "hasField",
    value: function hasField(name) {
      return this._fields.has(name);
    }
  }, {
    key: "getValues",
    value: function getValues(props) {
      var _this14 = this;

      var values = {};
      props = props ? props : {};

      this._fields.each(function (field) {
        var name = field.get('name');

        if ((props.in === undefined || props.in === !!field.get('in')) && (props.out === undefined || props.out === !!field.get('out')) && (props.blank === undefined || props.blank === !!field.isBlank()) && (props.default === undefined || props.default === !!_this14.isDefaultField(name))) {
          values[name] = field.get('value');
        }
      });

      return values;
    }
  }, {
    key: "_validateValuesType",
    value: function _validateValuesType(values) {
      var hasError = false;

      if (values === null || (0, _typeof2.default)(values) === 'object' && !Array.isArray(values)) {// No error
      } else {
        hasError = true;
      }

      this._hasTypeError = hasError;
    }
  }, {
    key: "setValues",
    value: function setValues(values) {
      var _this15 = this;

      this._validateValuesType(values);

      this._clearExtraErrors();

      if (!this._hasTypeError) {
        if (values === null) {
          this.clearValues();
        } else {
          (0, _each.default)(values, function (value, name) {
            // Not a nested field? Nested fields in the values aren't supported, but we need to ignore
            // them as they are validate in component definitions
            if (name.indexOf('.') === -1) {
              if (_this15.hasField(name)) {
                _this15.getField(name).setValue(value);
              } else if (_this15.get('reportUndefined')) {
                _this15._extraErrors.push({
                  field: name,
                  error: 'undefined field'
                });
              }
            }
          });
        }
      }
    }
  }, {
    key: "clearValues",
    value: function clearValues() {
      this._fields.each(function (field) {
        return field.clearValue();
      });
    }
  }, {
    key: "clearErrs",
    value: function clearErrs() {
      this.set({
        err: null
      });

      this._fields.each(function (field) {
        return field.clearErr();
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      this.clearValues();
      this.clearErrs();
      this.set({
        pristine: true
      });
      this.setTouched(false);
    }
  }, {
    key: "_toValidatorProps",
    value: function _toValidatorProps() {
      return this;
    }
  }, {
    key: "_validateWithValidators",
    value: function _validateWithValidators() {
      var _this16 = this;

      if (this._validators && this._validators.length > 0) {
        var validator = new _validator.default(this._toValidatorProps());
        var errors = validator.validate(this._validators);

        if (errors.length !== 0) {
          errors.forEach(function (error) {
            _this16.getField(error.field).setErr(error.error);
          });
        }
      }
    }
  }, {
    key: "canSubmit",
    value: function canSubmit() {
      // return !this.hasErrorForTouchedField() && this.get('dirty');
      return !this.hasErrorForField() && this.get('dirty');
    }
  }, {
    key: "_emitCanOrCannotSubmit",
    value: function _emitCanOrCannotSubmit() {
      // Emit a canSubmit or cannotSubmit event so that we can adjust buttons, etc...
      var canSubmit = this.canSubmit();

      if (canSubmit) {
        this._setSubmitDisabled(false);
      } // this._setSubmitDisabled(!canSubmit);


      this.emitChange(canSubmit ? 'canSubmit' : 'cannotSubmit');
    }
  }, {
    key: "validate",
    value: function validate() {
      this.clearErrs();

      this._fields.each(function (field) {
        return field.validate();
      }); // TODO: should we also support functional validators? Probably as more powerful when working
      // just with JS. Other option is to extend form and define new validate().
      // this._validators.forEach(validator => validator(this));


      this._validateWithValidators();

      if (this._hasTypeError || this._extraErrors.length > 0) {
        this.set({
          err: true
        });
      }

      this._emitCanOrCannotSubmit();
    }
  }, {
    key: "addValidator",
    value: function addValidator(validator) {
      this._validators.push(validator);
    }
  }, {
    key: "setTouched",
    value: function setTouched(touched) {
      this.set({
        touched: touched
      });

      this._fields.each(function (field) {
        return field.set({
          touched: touched
        });
      });
    }
  }, {
    key: "setRequired",
    value: function setRequired(required) {
      this._fields.each(function (field) {
        return field.set({
          required: required
        });
      });
    }
  }, {
    key: "setDisabled",
    value: function setDisabled(disabled) {
      this._fields.each(function (field) {
        return field.set({
          disabled: disabled
        });
      });
    }
  }, {
    key: "setEditable",
    value: function setEditable(editable) {
      this._fields.each(function (field) {
        return field.set({
          editable: editable
        });
      });
    }
  }, {
    key: "setHidden",
    value: function setHidden(hidden) {
      this._fields.each(function (field) {
        return field.set({
          hidden: hidden
        });
      });
    }
  }, {
    key: "setOut",
    value: function setOut(out) {
      this._fields.each(function (field) {
        return field.set({
          out: out
        });
      });
    }
  }, {
    key: "setSnapshot",
    value: function setSnapshot(snapshot) {
      var _this17 = this;

      if (snapshot === 'restore') {
        if (this._snapshotFields) {
          this._snapshotFields.forEach(function (field) {
            _this17.getField(field.name).set(field);
          });
        }
      } else {
        // Take
        var fields = this.mapFields(function (field) {
          return field.get(['name', 'hidden', 'required', 'out', 'in']);
        });
        this._snapshotFields = fields;
      }
    } // TODO: remove and use set({ pristine }) instead?

  }, {
    key: "setDirty",
    value: function setDirty(dirty) {
      this.set({
        dirty: dirty
      });

      this._fields.each(function (field) {
        return field.set({
          dirty: dirty
        });
      });
    }
  }, {
    key: "_setFullWidth",
    value: function _setFullWidth(fullWidth) {
      this._fields.each(function (field) {
        return field.set({
          fullWidth: fullWidth
        });
      });
    }
  }, {
    key: "clone",
    value: function clone() {
      // It is much faster to call field.clone() instead of doing a cloneDeep of field as
      // field.clone() can use field._cloneFast()
      var clonedFields = this.mapFields(function (field) {
        return field.clone();
      });
      var opts = {};

      var canCloneFast = this._canCloneFast();

      if (canCloneFast) {
        // We exclude the fields from the deep clone and clone them manually
        opts = {
          defaultProps: {
            fields: clonedFields
          },
          excludeProps: ['fields']
        };
      }

      var clonedForm = this._clone(opts);

      if (!canCloneFast) {
        clonedForm.set({
          fields: clonedFields
        });
      }

      return clonedForm;
    }
  }, {
    key: "hasSetErrors",
    value: function hasSetErrors() {
      return this._hasTypeError || this._extraErrors.length > 0;
    }
  }, {
    key: "getErrs",
    value: function getErrs() {
      var errs = [];

      if (this._hasTypeError) {
        errs.push({
          error: 'must be an object'
        });
      } else {
        if (this._extraErrors.length > 0) {
          errs = errs.concat(this._extraErrors);
        } // Only if there we haven't encountered errors during the last set do we want to calculate the
        // field errors as these set errors can often cause field errors and we want to focus on the
        // root cause.


        this._fields.each(function (field) {
          var err = field.getErr();

          if (err) {
            errs.push({
              field: field.get('name'),
              error: err
            });
          }
        });
      }

      return errs;
    }
  }, {
    key: "hasErr",
    value: function hasErr() {
      return this.get('err') ? true : false;
    } // TODO: make this more efficient by using a prop that is set by the field listeners. This way the
    // value is cached.

  }, {
    key: "hasErrorForTouchedField",
    value: function hasErrorForTouchedField() {
      var hasErr = false;

      this._fields.each(function (field) {
        if (field.get('touched') && field.getErr()) {
          hasErr = true;
          return false; // exit loop
        }
      });

      return hasErr;
    } // TODO: make this more efficient by using a prop that is set by the field listeners. This way the
    // value is cached.

  }, {
    key: "hasErrorForField",
    value: function hasErrorForField() {
      var hasErr = false;

      this._fields.each(function (field) {
        if (field.getErr()) {
          hasErr = true;
          return false; // exit loop
        }
      });

      return hasErr;
    }
  }, {
    key: "_getSubmitButton",
    value: function _getSubmitButton() {
      var button = null;
      this.eachField(function (field) {
        if (field instanceof _buttonField.default && field.get('type') === 'submit') {
          button = field;
          return false; // exit loop
        }
      });
      return button;
    }
  }, {
    key: "_emitClickOnButton",
    value: function _emitClickOnButton(button) {
      button.emitClick();
    }
  }, {
    key: "submit",
    value: function submit() {
      var button = this._getSubmitButton();

      if (button) {
        this._emitClickOnButton(button);
      }
    }
  }, {
    key: "getFields",
    value:
    /*#__PURE__*/
    _regenerator.default.mark(function getFields() {
      return _regenerator.default.wrap(function getFields$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.delegateYield(this._fields.values(), "t0", 1);

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, getFields, this);
    })
  }, {
    key: "isBlank",
    value: function isBlank() {
      var isBlank = true;

      this._fields.each(function (field) {
        if (!field.isBlank()) {
          isBlank = false;
          return false; // exit loop
        }
      });

      return isBlank;
    }
  }, {
    key: "eachField",
    value: function eachField(onField) {
      this._fields.each(function (field, name, last) {
        return onField(field, name, last);
      });
    }
  }, {
    key: "mapFields",
    value: function mapFields(onField) {
      return this._fields.map(function (field, name, last) {
        return onField(field, name, last);
      });
    }
  }, {
    key: "buildSchemaForm",
    value: function buildSchemaForm(form, compiler) {
      (0, _get2.default)((0, _getPrototypeOf3.default)(Form.prototype), "buildSchemaForm", this).call(this, form, compiler); // Wrap factory so that it sets the compiler

      var formFactory = form.getField('fields').get('formFactory');

      var _product = formFactory.get('product');

      formFactory.set({
        product: function product() {
          var form = _product();

          form.set({
            compiler: compiler
          });
          return form;
        }
      }); // Monkey patch setValues so that we can dynamically set the fieldNames when validating the
      // access

      var origSetValues = form.setValues;

      form.setValues = function (values) {
        var fieldNames = [];

        if (values.fields) {
          values.fields.forEach(function (field) {
            // Was a name specified? It may not have been if there is an error in the fields def
            if (field.name) {
              fieldNames.push(field.name);
            }
          });
        }

        if (values.component) {
          // Get inherited fields
          var extendedForm = compiler.newComponent({
            component: values.component
          });
          extendedForm.eachField(function (field) {
            return fieldNames.push(field.get('name'));
          });
        }

        form.getField('access').getForm().set({
          fieldNames: fieldNames
        });
        origSetValues.apply(this, arguments);
      };
    }
  }, {
    key: "getValue",
    value: function getValue(fieldName) {
      return this.getField(fieldName).getValue();
    } // TODO: refactor calls in this class to use setForEachField when possible

  }, {
    key: "setForEachField",
    value: function setForEachField(props) {
      this._fields.each(function (field) {
        return field.set(props);
      });
    }
  }, {
    key: "setUseDisplayValue",
    value: function setUseDisplayValue(useDisplayValue) {
      this.setForEachField({
        useDisplayValue: useDisplayValue
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      (0, _get2.default)((0, _getPrototypeOf3.default)(Form.prototype), "destroy", this).call(this);
      this.eachField(function (field) {
        return field.destroy();
      });
    }
  }, {
    key: "setFieldErr",
    value: function setFieldErr(fieldName, err) {
      this.getField(fieldName).setErr(err);
    }
  }, {
    key: "toErr",
    value: function toErr() {
      return new _formErr.default({
        form: this
      });
    }
  }, {
    key: "setFieldErrAndThrow",
    value: function setFieldErrAndThrow(fieldName, err) {
      this.setFieldErr(fieldName, err);
      throw this.toErr();
    }
  }]);
  return Form;
}(_component.default);

exports.default = Form;