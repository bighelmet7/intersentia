"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _field = _interopRequireDefault(require("./field"));

var _globals = _interopRequireDefault(require("../globals"));

var _collectionMapa = _interopRequireDefault(require("./collection-mapa"));

var _infiniteLoader = _interopRequireDefault(require("../infinite-loader"));

var _component = _interopRequireDefault(require("../component"));

var _utils = _interopRequireDefault(require("../utils"));

var _each = _interopRequireDefault(require("lodash/each"));

// Note: We no longer instantiate a default store for the CollectionField as having a store
// introduces extra complexity that is not always needed. For example, when using the
// CollectionField without a store, you can use set() and get() to modify the underlying data
// synchronously, which is useful for small datasets, e.g. nested form data. When using a store;
// however, you have to account for the store being asynchronous, and therefore all manipulation of
// the data should go through the store.
var CollectionField =
/*#__PURE__*/
function (_Field) {
  (0, _inherits2.default)(CollectionField, _Field);

  function CollectionField() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, CollectionField);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(CollectionField)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_className", 'CollectionField');
    return _this;
  }

  (0, _createClass2.default)(CollectionField, [{
    key: "_create",
    value: function _create(props) {
      (0, _get2.default)((0, _getPrototypeOf3.default)(CollectionField.prototype), "_create", this).call(this, props);
      var c = this.constructor; // For mocking

      this._window = global.window;
      this._document = global.document;
      this._globals = _globals.default;
      this.set({
        schema: {
          component: 'Form',
          fields: [{
            name: 'formFactory',
            component: 'Field',
            required: true
          }, {
            // Note: this prop is automatically generated using the formFactory and can be read, but
            // should not be be set
            name: 'form',
            component: 'Field'
          }, {
            name: 'forbidCreate',
            component: 'BooleanField'
          }, {
            name: 'forbidUpdate',
            component: 'BooleanField'
          }, {
            name: 'forbidDelete',
            component: 'BooleanField'
          }, {
            name: 'forbidViewArchived',
            component: 'BooleanField'
          }, {
            name: 'forbidSearch',
            component: 'BooleanField'
          }, {
            name: 'forbidSort',
            component: 'BooleanField'
          }, {
            name: 'forbidOrder',
            component: 'BooleanField'
          }, {
            name: 'minSize',
            component: 'IntegerField'
          }, {
            name: 'maxSize',
            component: 'IntegerField'
          }, {
            name: 'singularLabel',
            component: 'TextField'
          }, {
            name: 'store',
            component: 'Field'
          }, {
            name: 'scrollThreshold',
            component: 'IntegerField'
          }, {
            name: 'itemsPerPage',
            component: 'IntegerField'
          }, {
            name: 'maxBufferPages',
            component: 'IntegerField'
          }, {
            name: 'spacerHeight',
            component: 'IntegerField'
          }, {
            name: 'spacerId',
            component: 'TextField'
          }, {
            name: 'bufferTopId',
            component: 'TextField'
          }, {
            name: 'isLoading',
            component: 'BooleanField'
          }, {
            name: 'order',
            component: 'Field'
          }, {
            name: 'currentForm',
            component: 'Field'
          }, {
            name: 'mode',
            component: 'TextField'
          }, {
            name: 'noResults',
            component: 'BooleanField'
          }, {
            name: 'pristine',
            component: 'BooleanField'
          }, {
            name: 'change',
            component: 'Field'
          }, {
            name: 'maxColumns',
            component: 'IntegerField'
          }, {
            name: 'skipRead',
            component: 'BooleanField'
          }, {
            name: 'includeExtraneous',
            component: 'BooleanField'
          }]
        }
      });

      this._setDefaults(props, {
        scrollThreshold: c.SCROLLTHRESHOLD_DEFAULT,
        itemsPerPage: c.ITEMS_PER_PAGE_DEFAULT,
        maxBufferPages: c.MAX_BUFFER_PAGES_DEFAULT,
        spacerHeight: 0,
        spacerId: _component.default.getNextUniqueId(),
        // Needed so that unload does not trigger listeners as these props would otherwise be
        // initialized as undefined
        order: null,
        mode: null,
        showArchived: false,
        searchString: null,
        // A good default for most content as to not wrap content, but to also take up less vertical
        // space
        maxColumns: 2,
        // By default, don't allow the user to order the items by dragging them
        forbidOrder: true
      });

      this._createInfiniteLoader(); // We use a Mapa instead of an array as it allows us to index the forms by id. We use a Mapa
      // instead of a Map as we may want to iterate through the forms beginning at any single form. //
      // Specifically, we use a CollectionStore as it maintains the order of the forms, because there
      // is no guarantee that the underlying store will be ordered.


      this._forms = new _collectionMapa.default();

      this._listenForLoaded();

      this._listenForUnload();

      this._listenForShowArchived();

      this._listenForSearchString();

      this._listenForOrder();

      this._listenForScroll();
    }
  }, {
    key: "_listenForLoaded",
    value: function _listenForLoaded() {
      var _this2 = this;

      this.on('didLoad',
      /*#__PURE__*/
      (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee() {
        var form;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // Wait for loaded event so that we have had a chance to load options, etc...
                if (_this2.get('formFactory')) {
                  // Regenerate the form so that we have one that has any loaded data
                  _this2._generateForm(_this2.get('formFactory')); // Emit load so that form can complete any listeners, e.g. taking snapshot


                  form = _this2.get('form');
                  form.emitLoad();
                }

                _this2._resetInfiniteLoader();

                _this2._updateInfiniteLoader();

                _context.next = 5;
                return _this2._infiniteLoader.getAll();

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })));
    }
  }, {
    key: "_onUnload",
    value: function _onUnload() {
      // Clear order, mode and showArchived so that we are ready for when we return
      this.set({
        order: null,
        mode: null,
        showArchived: false,
        searchString: null
      });

      if (this.get('formFactory')) {
        var form = this.get('form');
        form.emitUnload();
      }
    }
  }, {
    key: "_listenForUnload",
    value: function _listenForUnload() {
      var _this3 = this;

      this.on('unload', function () {
        _this3._onUnload();
      });
    }
  }, {
    key: "_resetInfiniteLoader",
    value: function _resetInfiniteLoader() {
      this._infiniteLoader.reset();
    }
  }, {
    key: "_getOrder",
    value: function _getOrder() {
      if (this.get('order')) {
        return this.get('order');
      } else {
        // Order by "order" as drag ordering is enabled
        return [['order', 'ASC']];
      }
    }
  }, {
    key: "_getWhere",
    value: function _getWhere() {
      if (this.get('searchString')) {
        return this._toWhereFromSearchString();
      } else {
        return undefined;
      }
    }
  }, {
    key: "_updateInfiniteLoader",
    value: function _updateInfiniteLoader() {
      // TODO: refactor to use getters like _getOrder() so that always using the latest showArchived,
      // etc...?
      this._infiniteLoader.setShowArchived(this.get('showArchived'));
    }
  }, {
    key: "_handleStoreChangeFactory",
    value: function _handleStoreChangeFactory() {
      var _this4 = this;

      return (
        /*#__PURE__*/
        function () {
          var _ref2 = (0, _asyncToGenerator2.default)(
          /*#__PURE__*/
          _regenerator.default.mark(function _callee2(name, value) {
            var muteChange, vv;
            return _regenerator.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    muteChange = false;
                    vv = value && value.value;
                    _context2.t0 = name;
                    _context2.next = _context2.t0 === 'createDoc' ? 5 : _context2.t0 === 'updateDoc' ? 5 : _context2.t0 === 'deleteDoc' ? 12 : 13;
                    break;

                  case 5:
                    if (!(_this4._forms.has(vv.id) && vv.archivedAt !== _this4._forms.get(vv.id).getValue('archivedAt'))) {
                      _context2.next = 9;
                      break;
                    }

                    return _context2.abrupt("return", _this4.removeForm(vv.id, muteChange));

                  case 9:
                    if (!(!!vv.archivedAt === _this4.get('showArchived'))) {
                      _context2.next = 11;
                      break;
                    }

                    return _context2.abrupt("return", _this4.upsertForm({
                      values: (0, _objectSpread2.default)({}, vv.fieldValues, {
                        id: vv.id,
                        archivedAt: vv.archivedAt,
                        userId: vv.userId,
                        order: vv.order
                      }),
                      muteChange: muteChange,
                      cursor: vv.cursor
                    }));

                  case 11:
                    return _context2.abrupt("break", 14);

                  case 12:
                    return _context2.abrupt("return", _this4.removeFormIfExists(vv.id, muteChange));

                  case 13:
                    return _context2.abrupt("break", 14);

                  case 14:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          return function (_x, _x2) {
            return _ref2.apply(this, arguments);
          };
        }()
      );
    }
  }, {
    key: "_setStore",
    value: function _setStore(newStore) {
      var store = this.get('store');

      if (newStore !== store) {
        if (store) {
          store.removeAllListeners();
        } // newStore can be falsy if the store is being cleared. TODO: is there a better way than doing
        // the typeof check to ensure that an empty RecordList doesn't bomb out when
        // newStore='{{store}}'?


        if (newStore && typeof newStore !== 'string') {
          newStore.on('$change', this._handleStoreChangeFactory());
        }

        this._set('store', newStore);
      }
    }
  }, {
    key: "_clearAndGetAll",
    value: function () {
      var _clearAndGetAll2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3() {
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                // Clear any existing forms. TODO: it would be more efficient to just record ids of all
                // existing items and then use getAll() result to determine if item needs to be inserted or
                // removed (if current id missing)
                this._forms.clear();

                this._resetInfiniteLoader();

                this._updateInfiniteLoader();

                _context3.next = 5;
                return this._infiniteLoader.getAll();

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _clearAndGetAll() {
        return _clearAndGetAll2.apply(this, arguments);
      }

      return _clearAndGetAll;
    }()
  }, {
    key: "_handleShowArchivedFactory",
    value: function _handleShowArchivedFactory() {
      var _this5 = this;

      return (
        /*#__PURE__*/
        function () {
          var _ref3 = (0, _asyncToGenerator2.default)(
          /*#__PURE__*/
          _regenerator.default.mark(function _callee4(showArchived) {
            return _regenerator.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _this5.set({
                      showArchived: showArchived
                    });

                    _context4.next = 3;
                    return _this5._clearAndGetAll();

                  case 3:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4);
          }));

          return function (_x3) {
            return _ref3.apply(this, arguments);
          };
        }()
      );
    }
  }, {
    key: "_listenForShowArchived",
    value: function _listenForShowArchived() {
      this.on('showArchived', this._handleShowArchivedFactory());
    }
  }, {
    key: "_toWhereFromSearchString",
    value: function _toWhereFromSearchString() {
      if (this.get('searchString')) {
        var form = this.get('form');
        var fieldNames = [];
        form.eachField(function (field) {
          // TODO: is it really best to filter by hidden? Better to filter by default? Or, by hidden is
          // good and expect user to specify fields if different?
          if (!field.get('hidden') && !form.isDefaultField(field.get('name'))) {
            fieldNames.push('fieldValues.' + field.get('name'));
          }
        });
        return _utils.default.toWhereFromSearchString(fieldNames, this.get('searchString'));
      } else {
        return null;
      }
    }
  }, {
    key: "_handleSearchStringFactory",
    value: function _handleSearchStringFactory() {
      var _this6 = this;

      return (
        /*#__PURE__*/
        function () {
          var _ref4 = (0, _asyncToGenerator2.default)(
          /*#__PURE__*/
          _regenerator.default.mark(function _callee5(searchString) {
            return _regenerator.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _this6.set({
                      searchString: searchString
                    }); // Is the component still loaded? We want to prevent issuing a new query when the searchString
                    // is cleared when we change our route.


                    if (!_this6.isLoaded()) {
                      _context5.next = 4;
                      break;
                    }

                    _context5.next = 4;
                    return _this6._clearAndGetAll();

                  case 4:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5);
          }));

          return function (_x4) {
            return _ref4.apply(this, arguments);
          };
        }()
      );
    }
  }, {
    key: "_listenForSearchString",
    value: function _listenForSearchString() {
      this.on('searchString', this._handleSearchStringFactory());
    }
  }, {
    key: "_handleOrderFactory",
    value: function _handleOrderFactory() {
      var _this7 = this;

      return (
        /*#__PURE__*/
        function () {
          var _ref5 = (0, _asyncToGenerator2.default)(
          /*#__PURE__*/
          _regenerator.default.mark(function _callee6(order) {
            return _regenerator.default.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    _this7.set({
                      order: order
                    }); // Is the component still loaded? We want to prevent issuing a new query when the order
                    // is cleared when we change our route.


                    if (!_this7.isLoaded()) {
                      _context6.next = 4;
                      break;
                    }

                    _context6.next = 4;
                    return _this7._clearAndGetAll();

                  case 4:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6);
          }));

          return function (_x5) {
            return _ref5.apply(this, arguments);
          };
        }()
      );
    } // TODO: would it be better to intercept set({ order }), etc... instead of using listeners?

  }, {
    key: "_listenForOrder",
    value: function _listenForOrder() {
      this.on('order', this._handleOrderFactory());
    }
  }, {
    key: "_handleScrollFactory",
    value: function _handleScrollFactory() {
      var _this8 = this;

      return function () {
        _this8._infiniteLoader.scroll({
          scrollY: _this8._window.scrollY
        });
      };
    }
  }, {
    key: "_listenForScroll",
    value: function _listenForScroll() {
      this.on('scroll', this._handleScrollFactory());
    }
  }, {
    key: "_onRemoveItems",
    value: function _onRemoveItems(id, n, reverse) {
      var i = 0;
      var lastId = null;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._forms.entries(id, reverse)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var entry = _step.value;
          lastId = entry[0];

          if (i++ === n) {
            break;
          } // We want to mute the changes or else we'll introduce a lot of latency on the UI thread.


          var muteChange = true;
          this.removeForm(lastId, muteChange);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return lastId;
    }
  }, {
    key: "_onResizeSpacer",
    value: function _onResizeSpacer(dHeight, height) {
      var newHeight = null; // Was an absolute height specified?

      if (height !== undefined) {
        newHeight = height;
      } else {
        // Change by a delta
        newHeight = this.get('spacerHeight') + dHeight;
      } // this._infiniteLoader may not exist yet


      var beginning = this._infiniteLoader ? this._infiniteLoader.beginningLoaded() : false;
      var surplus = 0;

      if (beginning && dHeight < 0) {
        // When expanding the screen and then scrolling up, the spacer may be lager than the space
        // needed. This is fine until we reach the top at which point we need to set the height of the
        // spacer to 0 and then scroll to account for the offset.
        surplus = -newHeight;
        newHeight = 0;
      } else if (newHeight < 0) {
        // The spacer has a negative height, probably because the screen size has changed
        surplus = -newHeight;
        newHeight = 0;
      }

      this.set({
        spacerHeight: newHeight
      }); // The spacer has no more space (probably because the screen shrinked) so we need to scroll
      // to make sure that the user stays at the same point in the list when the new items are
      // added at the top.

      if (surplus !== 0) {
        this._window.scrollBy({
          top: surplus,
          behavior: 'instant'
        });
      }
    }
  }, {
    key: "_onGetAll",
    value: function () {
      var _onGetAll2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee7(props) {
        var store, records, noResults;
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                store = this.get('store');

                if (!store) {
                  _context7.next = 9;
                  break;
                }

                _context7.next = 4;
                return store.getAllDocs(props);

              case 4:
                records = _context7.sent;
                // Did we get back an empty set of results and we are on the first page?
                noResults = records.edges.length === 0 && !props.after && !props.before;
                this.set({
                  noResults: noResults
                });

                if (noResults) {
                  // Set change to null to prevent issue where we toggle showArchived, get no archived results
                  // and then toggle showArchived again
                  this.set({
                    change: null
                  });
                }

                return _context7.abrupt("return", records);

              case 9:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _onGetAll(_x6) {
        return _onGetAll2.apply(this, arguments);
      }

      return _onGetAll;
    }()
  }, {
    key: "_getItemsPerPage",
    value: function _getItemsPerPage() {
      if (this.get('forbidOrder')) {
        return this.get('itemsPerPage');
      } else {
        // When drag ordering is enabled, we need to store all the docs in memory so that we can
        // reorder them. Reordering requires changing the "order" property for all affected docs.
        // FUTURE: we may want to support larger sets with drag ordering and will probably want to
        // utilize the pagination concepts in CollectionField and InfiniteLoader, but will have to
        // figure out how to load the entire set into the store so that items can be reordered.
        return this.constructor.MAX_ITEMS_PER_PAGE;
      }
    }
  }, {
    key: "_createInfiniteLoader",
    value: function _createInfiniteLoader() {
      var _this9 = this;

      this._infiniteLoader = new _infiniteLoader.default({
        onGetAll: function onGetAll(props) {
          return _this9._onGetAll(props);
        },
        onGetItemsPerPage: function onGetItemsPerPage() {
          return _this9._getItemsPerPage();
        },
        onGetScrollThreshold: function onGetScrollThreshold() {
          return _this9.get('scrollThreshold');
        },
        onGetMaxBufferPages: function onGetMaxBufferPages() {
          return _this9.get('maxBufferPages');
        },
        onGetItemElement: function onGetItemElement(id) {
          return _this9._document.getElementById(_this9.getUniqueItemId(id));
        },
        onGetSpacerElement: function onGetSpacerElement() {
          return _this9._document.getElementById(_this9.get('spacerId'));
        },
        onRemoveItems: function onRemoveItems(id, n, reverse) {
          return _this9._onRemoveItems(id, n, reverse);
        },
        onGetItems: function onGetItems(id, reverse) {
          return _this9._forms.values(id, reverse);
        },
        onResizeSpacer: function onResizeSpacer(dHeight, height) {
          return _this9._onResizeSpacer(dHeight, height);
        },
        onSetBufferTopId: function onSetBufferTopId(bufferTopId) {
          return _this9.set({
            bufferTopId: bufferTopId
          });
        },
        onGetItem: function onGetItem(id) {
          return _this9._forms.get(id);
        },
        onGetItemId: function onGetItemId(form) {
          return form.getValue('id');
        },
        onGetItemCursor: function onGetItemCursor(form) {
          return form.get('cursor');
        },
        onAddItems: function onAddItems(edges, beforeKey) {
          return _this9._onAddItems(edges, beforeKey);
        },
        onEmitChange: function onEmitChange(records) {
          return _this9.set({
            change: records
          });
        },
        onSetIsLoading: function onSetIsLoading(isLoading) {
          return _this9.set({
            isLoading: isLoading
          });
        },
        onGetOrder: function onGetOrder() {
          return _this9._getOrder();
        },
        onGetWhere: function onGetWhere() {
          return _this9._getWhere();
        }
      });
    }
  }, {
    key: "_listenToForm",
    value: function _listenToForm(form) {
      var _this10 = this;

      var props = ['dirty', 'touched'];
      props.forEach(function (prop) {
        form.on(prop, function (value) {
          if (value === true) {
            // We only set the parent value when it is true as want to avoid infinite recursion
            _this10.set((0, _defineProperty2.default)({}, prop, value));
          }
        });
      }); // TODO: is this needed? Does it introduce unneeded latency?
      // form.on('value', fieldValue => {
      //   // If no store then we assume that the data is being managed by the parent and therefore we need
      //   // to update the value
      //   if (!this.get('store')) {
      //     // We use _set() as if we used set() then we would trigger an infinite loop
      //     const value = this._value ? this._value : {};
      //     const index = this._forms.indexOf(form);
      //     value[index] = fieldValue;
      //     this._set('value', value); // Doesn't trigger event as shallow compare
      //     this.emitChange('value', value);
      //   }
      // });
    }
  }, {
    key: "_notifyUI",
    value: function _notifyUI(muteChange, change) {
      if (!muteChange) {
        // Emit change so that UI is notified
        this.set({
          change: change
        });
      }
    }
  }, {
    key: "_addForm",
    value: function _addForm(_ref6) {
      var form = _ref6.form,
          values = _ref6.values,
          muteChange = _ref6.muteChange,
          cursor = _ref6.cursor,
          beforeKey = _ref6.beforeKey;
      form.setValues(values);
      form.set({
        parent: this,
        cursor: cursor
      });
      var id = form.getField('id');
      var key = 0;

      if (id.isBlank()) {
        // The id value is blank so use the current _forms length as the key
        key = this._forms.length();
      } else {
        key = id.getValue();
      } // Set noResults to false as we now have results


      this.set({
        noResults: false
      }); // Add form to mapa

      this._forms.set(key, form, beforeKey);

      this._listenToForm(form);

      this._calcValue();

      this._notifyUI(muteChange, values);

      return form;
    }
  }, {
    key: "_produceFormAndWaitForLoad",
    value: function () {
      var _produceFormAndWaitForLoad2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee8() {
        var form;
        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                form = this.produce(); // Wait for component to be created so that UI components like the InfiniteLoader can determine
                // the exact size and location of the element when it is first rendered.

                _context8.next = 3;
                return form.resolveAfterCreate();

              case 3:
                // Trigger the load as would be done by the UI so that we can populate options, etc... This adds
                // extra latency (~100ms), but it is a useful construct. Load listeners, especially those that
                // take a while, should be avoided.
                form.emitLoad();
                _context8.next = 6;
                return form.resolveAfterLoad();

              case 6:
                return _context8.abrupt("return", form);

              case 7:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _produceFormAndWaitForLoad() {
        return _produceFormAndWaitForLoad2.apply(this, arguments);
      }

      return _produceFormAndWaitForLoad;
    }()
  }, {
    key: "_produceFormWaitForLoadAndPushForm",
    value: function () {
      var _produceFormWaitForLoadAndPushForm2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee9(forms) {
        var form;
        return _regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this._produceFormAndWaitForLoad();

              case 2:
                form = _context9.sent;
                forms.push(form);

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function _produceFormWaitForLoadAndPushForm(_x7) {
        return _produceFormWaitForLoadAndPushForm2.apply(this, arguments);
      }

      return _produceFormWaitForLoadAndPushForm;
    }()
  }, {
    key: "_onAddItems",
    value: function () {
      var _onAddItems2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee10(edges, beforeKey) {
        var _this11 = this;

        var forms, promises, i, muteChange, _loop, _i;

        return _regenerator.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                // It is much more efficient to batch the creation and event waiting on the forms so that the
                // promises can be executed concurrently.
                forms = [];
                promises = [];

                for (i = 0; i < edges.length; i++) {
                  promises.push(this._produceFormWaitForLoadAndPushForm(forms));
                }

                _context10.next = 5;
                return Promise.all(promises);

              case 5:
                // To reduce latency, mute changes for individual forms. InfiniteLoader will emit a change event
                // after all the forms have been added.
                muteChange = true;

                _loop = function _loop(_i) {
                  var edge = edges[_i];
                  var node = edge.node;
                  var values = {
                    id: node.id,
                    userId: node.userId,
                    createdAt: node.createdAt,
                    updatedAt: node.updatedAt,
                    archivedAt: node.archivedAt,
                    order: node.order
                  };
                  var form = forms[_i]; // Make sure the corresponding fields exist in the form. This is done so that extraneous data
                  // in the store, e.g. because a field has since been deleted, is just ignored.

                  (0, _each.default)(node.fieldValues, function (value, name) {
                    if (value && (_this11.get('includeExtraneous') || form.hasField(name))) {
                      values[name] = value;
                    }
                  });

                  _this11._addForm({
                    form: form,
                    values: values,
                    muteChange: muteChange,
                    cursor: edge.cursor,
                    beforeKey: beforeKey
                  });
                };

                for (_i = 0; _i < edges.length; _i++) {
                  _loop(_i);
                }

              case 8:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function _onAddItems(_x8, _x9) {
        return _onAddItems2.apply(this, arguments);
      }

      return _onAddItems;
    }()
  }, {
    key: "produce",
    value: function produce() {
      // Note: a previous design cloned an instance of a form to generate a new form. Cloning a form
      // is VERY slow, it requires a recursive dive into the instance because the original class
      // structure isn't immediately recoverable once a class has been instantiated. Instead, it is
      // much faster to generate a form via a factory.
      var factory = this.get('formFactory');
      return factory.produce();
    }
  }, {
    key: "_addFormSynchronous",
    value: function _addFormSynchronous(args) {
      var form = this.produce();
      return this._addForm(Object.assign({
        form: form
      }, args));
    }
  }, {
    key: "_addFormAsynchronous",
    value: function () {
      var _addFormAsynchronous2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee11(args) {
        var form;
        return _regenerator.default.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this._produceFormAndWaitForLoad();

              case 2:
                form = _context11.sent;
                return _context11.abrupt("return", this._addForm(Object.assign({
                  form: form
                }, args)));

              case 4:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function _addFormAsynchronous(_x10) {
        return _addFormAsynchronous2.apply(this, arguments);
      }

      return _addFormAsynchronous;
    }()
  }, {
    key: "addForm",
    value: function addForm(_ref7) {
      var form = _ref7.form,
          values = _ref7.values,
          muteChange = _ref7.muteChange,
          cursor = _ref7.cursor,
          beforeKey = _ref7.beforeKey,
          synchronous = _ref7.synchronous;
      var args = {
        values: values,
        muteChange: muteChange,
        cursor: cursor,
        beforeKey: beforeKey
      };

      if (form) {
        // A form is being supplied so save some CPU processing by using the form instead of
        // generating another form
        return this._addForm(Object.assign({
          form: form
        }, args));
      } else if (synchronous) {
        // Add the form synchronously, i.e. don't wait for any events
        return this._addFormSynchronous(args);
      } else {
        // Add the form asynchronously, i.e. wait for the didCreate and didLoad events
        return this._addFormAsynchronous(args);
      }
    }
  }, {
    key: "_clearAllFormListeners",
    value: function _clearAllFormListeners() {
      this.eachForm(function (form) {
        return form.removeAllListeners();
      });
    }
  }, {
    key: "_validateValueType",
    value: function _validateValueType(value) {
      var hasError = false;

      if (value === null) {// No error
      } else if (Array.isArray(value)) {
        if (value.length > 0 && (0, _typeof2.default)(value[0]) !== 'object') {
          hasError = true;
        } else {// No error
        }
      } else {
        hasError = true;
      }

      this._hasTypeError = hasError;
    }
  }, {
    key: "_setValue",
    value: function _setValue(value) {
      var _this12 = this;

      this._validateValueType(value);

      if (!this._hasTypeError) {
        // TODO: what's the best way to set? e.g. if we set the same values over and over then we end
        // up recreating the forms each time. Would it be better to just use index to set and if there
        // are indexes that are in the current forms, but not in values then just delete?
        this._clearAllFormListeners(); // prevent listener leaks


        this._forms.clear();

        if (value && value.length > 0) {
          // Note: we add the form synchronously because set() and get() must remain synchronous (core
          // design principle of MSON). In other words, we don't wait for the didCreate or didLoad
          // events when creating the form.
          var synchronous = true;
          value.forEach(function (values) {
            return _this12.addForm({
              values: values,
              synchronous: synchronous
            });
          });
        } // Emit change so that UI is notified


        this.set({
          change: value
        });
      }
    }
  }, {
    key: "removeForm",
    value: function removeForm(id, muteChange) {
      if (!muteChange) {
        // Inform the InfiniteLoader that we are removing an item so that it can adjust it's buffer,
        // etc...
        this._infiniteLoader.removeItem(id);
      }

      var form = this._forms.get(id);

      form.removeAllListeners();

      this._forms.delete(id);

      this._calcValue();

      this._notifyUI(muteChange, form.getValues());

      return form;
    }
  }, {
    key: "removeFormIfExists",
    value: function removeFormIfExists(id, muteChange) {
      if (this._forms.has(id)) {
        return this.removeForm(id, muteChange);
      }
    }
  }, {
    key: "getForm",
    value: function getForm(id) {
      return this._forms.get(id);
    }
  }, {
    key: "eachForm",
    value: function eachForm(onForm) {
      this._forms.each(onForm);
    }
  }, {
    key: "mapForms",
    value: function mapForms(onForm) {
      return this._forms.map(onForm);
    }
  }, {
    key: "_setForAllForms",
    value: function _setForAllForms(props) {
      this.eachForm(function (form) {
        return form.set(props);
      });
    }
  }, {
    key: "_setOnAllForms",
    value: function _setOnAllForms(props, propNames, expValue) {
      var _this13 = this;

      propNames.forEach(function (name) {
        if (props[name] !== undefined && (expValue === undefined || props[name] === expValue)) {
          _this13._setForAllForms((0, _defineProperty2.default)({}, name, props[name]));
        }
      });
    }
  }, {
    key: "_prepareForm",
    value: function _prepareForm(form) {
      form.setTouched(false);
      form.clearErrs();
      form.setDirty(false);
    }
  }, {
    key: "_copyValuesToCurrentForm",
    value: function _copyValuesToCurrentForm(form, currentForm) {
      var values = currentForm.getValues();
      form.clearValues();
      form.set({
        value: values
      });
    }
  }, {
    key: "_setCurrentForm",
    value: function _setCurrentForm(currentForm) {
      var form = this.get('form');

      if (currentForm === null) {
        // Clean up previous form
        form.destroy(); // Generate a new form so that we have any initial values and structure

        form = this._generateForm(this.get('formFactory'));
      } else {
        this._copyValuesToCurrentForm(form, currentForm);

        this._set('currentForm', currentForm);
      }

      this._prepareForm(form);
    }
  }, {
    key: "_readMode",
    value: function _readMode() {
      var form = this.get('form');
      form.emitChange('beginRead', form.getValue('id'));
      form.setEditable(false);
    }
  }, {
    key: "_createMode",
    value: function _createMode() {
      var form = this.get('form');
      form.emitChange('beginCreate');
      form.setEditable(true);
    }
  }, {
    key: "_updateMode",
    value: function _updateMode() {
      var form = this.get('form');
      form.emitChange('beginUpdate', form.getValue('id'));
      form.setEditable(true);
    }
  }, {
    key: "_emitEndEvents",
    value: function _emitEndEvents() {
      var form = this.get('form');
      var id = form.getValue('id');

      switch (this._mode) {
        case 'create':
          form.emitChange('endCreate', id);
          break;

        case 'update':
          form.emitChange('endUpdate', id);
          break;

        default:
          // case 'read':
          form.emitChange('endRead', id);
          break;
      }
    }
  }, {
    key: "_setParentDisableSubmit",
    value: function _setParentDisableSubmit(disableSubmit) {
      // Used to disable the submit action on the parent so that when the user clicks a submit button
      // for this CollectionField, it doesn't trigger a submit on the parent form. The parent may not
      // exist if this field is being used as a standlone component or it is the root component.
      if (this.get('parent')) {
        this.get('parent').set({
          disableSubmit: disableSubmit
        });
      }
    }
  }, {
    key: "_setMode",
    value: function _setMode(mode) {
      // Has a previous mode?
      if (this._mode) {
        this._emitEndEvents();
      } else {
        // The dialog is being opened
        this._setParentDisableSubmit(true);
      } // Note: we set the parent here instead of in set() as otherwise we create a circular
      // dependency that the Compiler doesn't support.


      var form = this.get('form');
      form.set({
        parent: this
      });

      switch (mode) {
        case 'create':
          this._createMode();

          break;

        case 'update':
          this._updateMode();

          break;

        case 'read':
          this._readMode();

          break;

        default:
          // The dialog is being closed
          this._setParentDisableSubmit(false);

          break;
      }

      form.set({
        mode: mode
      });

      this._set('mode', mode);
    }
  }, {
    key: "_generateForm",
    value: function _generateForm(factory) {
      // Generate a form so that we have access to the field names, etc...
      var form = factory.produce();
      this.set({
        form: form
      });
      return form;
    }
  }, {
    key: "_setMaxColumns",
    value: function _setMaxColumns(maxColumns) {
      // 12 (the number of grids) must be divisble by maxColumns. And, we require a power of 2 so that
      // we can shrink the screen and not have gaps in our grid, i.e. each layer is an even multiple
      // of the previous.
      var allowed = [1, 2, 4, 6, 12];

      if (allowed.indexOf(maxColumns) === -1) {
        throw new Error('maxColumns must be ' + allowed.join(','));
      } else {
        this._set('maxColumns', maxColumns);
      }
    }
  }, {
    key: "set",
    value: function set(props) {
      (0, _get2.default)((0, _getPrototypeOf3.default)(CollectionField.prototype), "set", this).call(this, Object.assign({}, props, {
        currentForm: undefined,
        mode: undefined,
        store: undefined,
        maxColumns: undefined
      })); // Set properties on all forms

      this._setOnAllForms(props, ['disabled', 'editable', 'pristine']); // Only set properties of forms if property is false


      this._setOnAllForms(props, ['dirty', 'touched'], false); // Only set properties of forms if property is null


      this._setOnAllForms(props, ['err'], null);

      if (props.currentForm !== undefined) {
        this._setCurrentForm(props.currentForm);
      }

      if (props.mode !== undefined && props.mode !== this._mode) {
        this._setMode(props.mode);
      }

      if (props.store !== undefined) {
        this._setStore(props.store);
      }

      if (props.maxColumns !== undefined) {
        this._setMaxColumns(props.maxColumns);
      }
    }
  }, {
    key: "_getValue",
    value: function _getValue() {
      return this._forms.map(function (form) {
        return form.getValues();
      });
    }
  }, {
    key: "getOne",
    value: function getOne(name) {
      if (name === 'value') {
        return this._getValue();
      }

      if (name === 'form' && !this._form) {
        // We have to generate a form immediately so that we have a place holder for the UI. After we
        // receive didLoad, we'll regenerate the form so that we'll also have the loaded data.
        // Generating the form on demand allows us to instantiate a factory where the product is a
        // missing template parameter, which is useful for testing.
        this._generateForm(this.get('formFactory'));
      }

      return (0, _get2.default)((0, _getPrototypeOf3.default)(CollectionField.prototype), "getOne", this).call(this, name);
    }
  }, {
    key: "getForms",
    value:
    /*#__PURE__*/
    _regenerator.default.mark(function getForms() {
      return _regenerator.default.wrap(function getForms$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              return _context12.delegateYield(this._forms.values(), "t0", 1);

            case 1:
            case "end":
              return _context12.stop();
          }
        }
      }, getForms, this);
    })
  }, {
    key: "updateForm",
    value: function updateForm(_ref8) {
      var values = _ref8.values,
          muteChange = _ref8.muteChange,
          cursor = _ref8.cursor,
          beforeKey = _ref8.beforeKey;

      var fieldForm = this._forms.get(values.id);

      var isOrderChanging = fieldForm.getValue('order') !== values.order;
      fieldForm.setValues(values);
      fieldForm.set({
        cursor: cursor
      });

      if (beforeKey === undefined && isOrderChanging) {
        // Explicitly get the beforeKey as we are updating the values in place and so the
        // CollectionMapa will not be able to detect the change in order
        beforeKey = this._forms.getBeforeId(fieldForm);
      }

      this._forms.set(values.id, fieldForm, beforeKey);

      this._calcValue();

      this._notifyUI(muteChange, values);

      return fieldForm;
    }
  }, {
    key: "_calcValue",
    value: function _calcValue() {
      // If no store then we assume that the data is being managed by the parent and therefore we need
      // to update the value
      if (!this.get('store')) {
        // We set the entire value as items may have moved and we want to make sure that the value reflects
        // this. We use _set() as if we used set() then we would trigger an infinite loop
        var value = this._getValue();

        this._set('value', value);

        this.set({
          dirty: true
        });
      }
    }
  }, {
    key: "upsertForm",
    value: function upsertForm(_ref9) {
      var values = _ref9.values,
          muteChange = _ref9.muteChange,
          cursor = _ref9.cursor,
          beforeKey = _ref9.beforeKey;

      if (this._forms.has(values.id)) {
        return this.updateForm({
          values: values,
          muteChange: muteChange,
          cursor: cursor,
          beforeKey: beforeKey
        });
      } else {
        return this.addForm({
          values: values,
          muteChange: muteChange,
          cursor: cursor,
          beforeKey: beforeKey
        });
      }
    }
  }, {
    key: "_saveForm",
    value: function () {
      var _saveForm2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee12(form) {
        var id, store, creating, fieldForm, reorder, record;
        return _regenerator.default.wrap(function _callee12$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                id = form.getField('id');
                store = this.get('store');
                creating = id.isBlank();
                fieldForm = null;

                if (!store) {
                  _context13.next = 19;
                  break;
                }

                // Set the order; otherwise, new items may not appear in the order in which they are added
                // as the order of docs in the store can be arbitrary
                reorder = !this.get('forbidOrder');
                record = null; // New?

                if (!creating) {
                  _context13.next = 13;
                  break;
                }

                _context13.next = 10;
                return store.createDoc({
                  form: form,
                  reorder: reorder
                });

              case 10:
                record = _context13.sent;
                _context13.next = 16;
                break;

              case 13:
                _context13.next = 15;
                return store.updateDoc({
                  form: form,
                  reorder: reorder
                });

              case 15:
                record = _context13.sent;

              case 16:
                form.setValues({
                  id: record.id,
                  createdAt: record.createdAt,
                  updatedAt: record.updatedAt,
                  order: record.order,
                  userId: record.userId
                });
                _context13.next = 20;
                break;

              case 19:
                if (creating) {
                  // TODO: use the id from this._docs.set instead of this dummy id
                  id.setValue(_utils.default.uuid());
                }

              case 20:
                fieldForm = this.upsertForm({
                  // Specify the form so that we don't have to generate another one
                  form: form,
                  values: form.getValues(),
                  muteChange: false,
                  cursor: form.get('cursor')
                });
                form.emitChange(creating ? 'didCreateRecord' : 'didUpdateRecord', id.getValue());
                return _context13.abrupt("return", fieldForm);

              case 23:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee12, this);
      }));

      function _saveForm(_x11) {
        return _saveForm2.apply(this, arguments);
      }

      return _saveForm;
    }()
  }, {
    key: "save",
    value: function () {
      var _save = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee13() {
        var form, fieldForm;
        return _regenerator.default.wrap(function _callee13$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                form = this.get('form'); // No errors?

                form.setTouched(true);
                form.validate();

                if (form.hasErr()) {
                  _context14.next = 10;
                  break;
                }

                _context14.next = 6;
                return this._saveForm(form);

              case 6:
                fieldForm = _context14.sent;

                this._globals.displaySnackbar(this.getSingularLabel() + ' saved'); // Set the currentForm to the new/updated form so that subsequent viewing or editing uses this
                // new data
                //
                // TODO: create a prop called 'readAfterSave' that sets the mode to read instead of null
                //
                // this.set({ currentForm: fieldForm, mode: 'read' });


                this.set({
                  currentForm: fieldForm,
                  mode: null
                });
                return _context14.abrupt("return", fieldForm);

              case 10:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee13, this);
      }));

      function save() {
        return _save.apply(this, arguments);
      }

      return save;
    }()
  }, {
    key: "archive",
    value: function () {
      var _archive = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee14(form) {
        var store, record;
        return _regenerator.default.wrap(function _callee14$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                store = this.get('store');

                if (!store) {
                  _context15.next = 6;
                  break;
                }

                _context15.next = 4;
                return store.archiveDoc({
                  form: form,
                  id: form.getValue('id'),
                  reorder: !this.get('forbidOrder')
                });

              case 4:
                record = _context15.sent;
                form.setValues({
                  archivedAt: record.archivedAt
                });

              case 6:
                // // Not showing archived?
                // if (!this.get('showArchived')) {
                // Remove from list. We have to use removeFormIfExists as there may be a race condition where
                // the store has already resulted in the form being removed.
                this.removeFormIfExists(form.getValue('id')); // }

                form.emitChange('didArchiveRecord', form.getValue('id'));

                this._globals.displaySnackbar(this.getSingularLabel() + ' deleted');

              case 9:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee14, this);
      }));

      function archive(_x12) {
        return _archive.apply(this, arguments);
      }

      return archive;
    }()
  }, {
    key: "restore",
    value: function () {
      var _restore = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee15(form) {
        var store;
        return _regenerator.default.wrap(function _callee15$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                store = this.get('store');

                if (!store) {
                  _context16.next = 4;
                  break;
                }

                _context16.next = 4;
                return store.restoreDoc({
                  form: form,
                  id: form.getValue('id'),
                  reorder: !this.get('forbidOrder')
                });

              case 4:
                form.setValues({
                  archivedAt: null
                }); // Remove from list as assume that we are only viewing archived items. We have to use
                // removeFormIfExists as there may be a race condition where the store has already resulted in
                // the form being removed. TODO: make this configurable via a param to restore?

                this.removeFormIfExists(form.getValue('id'));
                form.emitChange('didRestoreRecord', form.getValue('id'));

                this._globals.displaySnackbar(this.getSingularLabel() + ' restored');

              case 8:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee15, this);
      }));

      function restore(_x13) {
        return _restore.apply(this, arguments);
      }

      return restore;
    }()
  }, {
    key: "_getMaxSize",
    value: function _getMaxSize() {
      return this.get('forbidOrder') ? this.get('maxSize') : this.constructor.MAX_ITEMS_PER_PAGE;
    }
  }, {
    key: "reachedMax",
    value: function reachedMax() {
      // TODO: this isn't working when there are multiple pages! Need to get length from store?
      var maxSize = this._getMaxSize();

      return maxSize !== null && this._forms.length() >= maxSize;
    }
  }, {
    key: "validate",
    value: function validate() {
      (0, _get2.default)((0, _getPrototypeOf3.default)(CollectionField.prototype), "validate", this).call(this);
      var errors = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this._forms.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var form = _step2.value;
          form.validate();

          if (form.hasErr()) {
            errors.push({
              id: form.getField('id').getValue(),
              error: form.getErrs()
            });
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var numForms = this._forms.length();

      var minSize = this.get('minSize');
      var maxSize = this.get('maxSize');

      if (minSize !== null && numForms < minSize) {
        errors.push({
          error: "".concat(minSize, " or more")
        });
      } else if (maxSize !== null && numForms > maxSize) {
        errors.push({
          error: "".concat(maxSize, " or less")
        });
      }

      if (this._hasTypeError) {
        errors.push({
          error: 'must be an array of objects'
        });
      }

      if (errors.length > 0) {
        this.setErr(errors);
      }
    }
  }, {
    key: "getSingularLabel",
    value: function getSingularLabel() {
      if (this.get('singularLabel')) {
        return this.get('singularLabel');
      } else if (this.get('label')) {
        return _utils.default.toSingular(this.get('label'));
      } else {
        return null;
      }
    }
  }, {
    key: "isBlank",
    value: function isBlank() {
      var isBlank = true;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.getForms()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var form = _step3.value;

          if (!form.isBlank()) {
            isBlank = false;
            break;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return isBlank;
    } // TODO: why does using this cause the following error? TypeError: Method get
    // TypedArray.prototype.length called on incompatible receiver [object Object] at Uint8Array.get
    // length [as length] (<anonymous>). See collection-field.test.js, it('should clone') for example
    //
    // clone() {
    //   const clonedField = super.clone();
    //
    //   // Clone form so that cloned field has a reference to a different form
    //   this.set({ form: this.get('form').clone() });
    //
    //   return clonedField;
    // }

  }, {
    key: "getUniqueItemId",
    value: function getUniqueItemId(id) {
      return this.getUniqueId() + '-item-' + id;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      (0, _get2.default)((0, _getPrototypeOf3.default)(CollectionField.prototype), "destroy", this).call(this);
      this.eachForm(function (form) {
        return form.destroy();
      });
    }
  }, {
    key: "moveForm",
    value: function moveForm(_ref10) {
      var sourceIndex = _ref10.sourceIndex,
          destinationIndex = _ref10.destinationIndex,
          muteChange = _ref10.muteChange;

      // We move the form via the beforeKey construct. Reordering of all the affected docs is done at
      // the store layer. This way we can support things like pagination in the CollectionField, while
      // allowing for reordering in the store.
      var keys = this._forms.keysAtIndexes([sourceIndex, destinationIndex]);

      var sourceKey = keys[sourceIndex];
      var destinationKey = keys[destinationIndex];
      var form = this.getForm(sourceKey);
      form.setValues({
        order: destinationIndex
      });
      var beforeKey = undefined;
      var afterKey = destinationKey;

      if (destinationIndex < sourceIndex) {
        // moving up?
        beforeKey = destinationKey;
        afterKey = undefined;
      } // Move


      this._forms.set(sourceKey, form, beforeKey, afterKey);

      this._calcValue();

      this._notifyUI(muteChange, form.getValues());

      return form;
    }
  }, {
    key: "moveAndSaveForm",
    value: function () {
      var _moveAndSaveForm = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee16(_ref11) {
        var sourceIndex, destinationIndex, muteChange, form;
        return _regenerator.default.wrap(function _callee16$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                sourceIndex = _ref11.sourceIndex, destinationIndex = _ref11.destinationIndex, muteChange = _ref11.muteChange;
                form = this.moveForm({
                  sourceIndex: sourceIndex,
                  destinationIndex: destinationIndex,
                  muteChange: muteChange
                });
                return _context17.abrupt("return", this._saveForm(form));

              case 3:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee16, this);
      }));

      function moveAndSaveForm(_x14) {
        return _moveAndSaveForm.apply(this, arguments);
      }

      return moveAndSaveForm;
    }()
  }]);
  return CollectionField;
}(_field.default);

exports.default = CollectionField;
(0, _defineProperty2.default)(CollectionField, "SCROLLTHRESHOLD_DEFAULT", 2000);
(0, _defineProperty2.default)(CollectionField, "ITEMS_PER_PAGE_DEFAULT", 20);
(0, _defineProperty2.default)(CollectionField, "MAX_BUFFER_PAGES_DEFAULT", 3);
(0, _defineProperty2.default)(CollectionField, "MAX_ITEMS_PER_PAGE", 100);