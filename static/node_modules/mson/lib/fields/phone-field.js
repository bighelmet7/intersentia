"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _textFieldHiddenSchema = _interopRequireDefault(require("./text-field-hidden-schema"));

var _map = _interopRequireDefault(require("lodash/map"));

var _countryTelephoneData = _interopRequireDefault(require("country-telephone-data"));

var EMPTY_MASK = [/./, /./, /./, /./];

var PhoneField =
/*#__PURE__*/
function (_TextFieldHiddenSchem) {
  (0, _inherits2.default)(PhoneField, _TextFieldHiddenSchem);

  function PhoneField() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, PhoneField);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(PhoneField)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_className", 'PhoneField');
    return _this;
  }

  (0, _createClass2.default)(PhoneField, [{
    key: "_stringToArrayMask",
    value: function _stringToArrayMask(mask) {
      return (0, _map.default)(mask, function (item) {
        return item === '.' ? /\d/ : item;
      });
    }
  }, {
    key: "_getMask",
    value: function _getMask(value) {
      if (value) {
        var countries = this.constructor.getCountriesByCode();

        if (value[0] === '+') {
          // Single-digit match
          var country = countries[value[1]]; // Double-digit match

          if (!country) {
            country = countries[[value[1], value[2]].join('')];
          } // Triple-digit match


          if (!country) {
            country = countries[[value[1], value[2], value[3]].join('')];
          }

          if (country) {
            return this._stringToArrayMask(country.format);
          }
        } else {
          return this.get('defaultMask');
        }
      } // When returning false, there appears to be a bug in MaskedInput (react layer) that causes
      // issues when clearing the input, i.e. the old value is still present. As a workaround, we'll
      // return a mask that allows the user to enter any four characters--enough to determine the
      // final mask.
      //
      // Disable mask so that user can user can enter the first few characters, which will determine
      // the applicable mask
      // return false;
      //


      return EMPTY_MASK;
    }
  }, {
    key: "_create",
    value: function _create(props) {
      var _this2 = this;

      (0, _get2.default)((0, _getPrototypeOf3.default)(PhoneField.prototype), "_create", this).call(this, props);
      this.set({
        schema: {
          component: 'Form',
          fields: [{
            name: 'defaultMask',
            component: 'TextField',
            label: 'Default Mask',
            docLevel: 'basic'
          }]
        }
      });

      this._setDefaults(props, {
        mask: function mask(value) {
          return _this2._getMask(value);
        },
        defaultMask: this._stringToArrayMask('(...) ...-....')
      });
    }
  }, {
    key: "toConformedValue",
    value: function toConformedValue(value) {
      var mask = this._getMask(value); // Is there a mask in which to conform?


      if (mask !== EMPTY_MASK) {
        return (0, _get2.default)((0, _getPrototypeOf3.default)(PhoneField.prototype), "toConformedValue", this).call(this, value);
      } else {
        return value;
      }
    }
  }, {
    key: "set",
    value: function set(props) {
      var clonedProps = Object.assign({}, props); // Convert to RegExps?

      if (clonedProps.defaultMask !== undefined) {
        clonedProps.defaultMask = this._formatMask(clonedProps.defaultMask);
      }

      if (clonedProps.value !== undefined) {
        clonedProps.value = this.toConformedValue(clonedProps.value);
      }

      (0, _get2.default)((0, _getPrototypeOf3.default)(PhoneField.prototype), "set", this).call(this, clonedProps);
    }
  }, {
    key: "_conformsToMask",
    value: function _conformsToMask(value, mask) {
      var conforms = true;
      mask.forEach(function (item, index) {
        if (item instanceof RegExp) {
          if (!item.test(value[index])) {
            conforms = false;
          }
        } else if (value[index] !== item) {
          conforms = false;
        }
      });
      return conforms;
    }
  }, {
    key: "validate",
    value: function validate() {
      (0, _get2.default)((0, _getPrototypeOf3.default)(PhoneField.prototype), "validate", this).call(this);

      if (!this.hasErr() && !this.isBlank()) {
        var value = this.getValue();

        var mask = this._getMask(value);

        if (mask === EMPTY_MASK || !this._conformsToMask(value, mask)) {
          this.setErr('invalid');
        }
      }
    }
  }], [{
    key: "getCountriesByCode",
    value: function getCountriesByCode() {
      if (!this.constructor._countriesByCode) {
        this.constructor._countriesByCode = {};
        var countriesByCode = this.constructor._countriesByCode;

        _countryTelephoneData.default.allCountries.forEach(function (country) {
          return countriesByCode[country.dialCode] = country;
        });
      }

      return this.constructor._countriesByCode;
    }
  }]);
  return PhoneField;
}(_textFieldHiddenSchema.default);

exports.default = PhoneField;