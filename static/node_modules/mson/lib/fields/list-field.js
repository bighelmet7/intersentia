"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _compositeField = _interopRequireDefault(require("./composite-field"));

var _utils = _interopRequireDefault(require("../utils"));

// NOTE: We opt to delete the fields instead of just hide them as this should allow for better reuse
// of resources
var ListField =
/*#__PURE__*/
function (_CompositeField) {
  (0, _inherits2.default)(ListField, _CompositeField);
  (0, _createClass2.default)(ListField, [{
    key: "_create",
    value: function _create(props) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(ListField.prototype), "_create", this).call(this, props);
      this._nextFieldName = 0;
      this.set({
        schema: {
          component: 'Form',
          fields: [{
            name: 'allowDelete',
            component: 'BooleanField'
          }, {
            name: 'minSize',
            component: 'IntegerField'
          }, {
            name: 'maxSize',
            component: 'IntegerField'
          }, {
            name: 'fieldFactory',
            component: 'Field',
            required: true
          }, {
            name: 'allowScalar',
            component: 'BooleanField'
          }, {
            name: 'singularLabel',
            component: 'TextField',
            label: 'Singular Label',
            docLevel: 'basic'
          }, {
            name: 'autoCreateFields',
            component: 'BooleanField'
          }, {
            name: 'startWithField',
            component: 'BooleanField'
          }, {
            name: 'canDeleteEmpty',
            component: 'BooleanField'
          }, {
            name: 'hideDeleteButton',
            component: 'BooleanField'
          }]
        }
      });

      this._setDefaults(props, {
        allowDelete: true,
        startWithField: props.fieldFactory,
        canDeleteEmpty: true
      });
    }
  }]);

  function ListField(props) {
    var _this;

    (0, _classCallCheck2.default)(this, ListField);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ListField).call(this, props));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_className", 'ListField');

    if (_this.get('startWithField')) {
      // Create the first field. We do this here and not in _create() as we may need the schema and
      // properties.
      _this._createNewField();
    }

    return _this;
  }

  (0, _createClass2.default)(ListField, [{
    key: "_createNewField",
    value: function _createNewField() {
      this.createField();
    }
  }, {
    key: "_getValue",
    value: function _getValue() {
      var values = [];
      this.eachField(function (field) {
        var value = field.getValue();

        if (value) {
          values.push(value);
        }
      });
      return values.length > 0 ? values : null;
    }
  }, {
    key: "_isLastFieldBlank",
    value: function _isLastFieldBlank() {
      return this._fields.last().isBlank();
    }
  }, {
    key: "_removeField",
    value: function _removeField(field) {
      if (this._fields.length() === 1) {
        // There is only 1 field so just clear the value
        field.clearValue();
      } else {
        var name = field.get('name');

        this._removeFieldByName(name); // Prevent listener leaks


        field.destroy();
      }

      this.emitChangeToField(field);

      this._calcValue(); // Create a new field if we have reached the max size and delete a field


      if (this.get('autoCreateFields') && !this._isLastFieldBlank() && this.canAddMoreFields()) {
        this.createField();
      }
    }
  }, {
    key: "_hasField",
    value: function _hasField(name) {
      return this._fields.has(name);
    }
  }, {
    key: "_clearFieldIfExists",
    value: function _clearFieldIfExists(name) {
      if (this._hasField(name)) {
        this._getField(name).clearValue();
      }
    }
  }, {
    key: "_shouldRemoveField",
    value: function _shouldRemoveField()
    /* field */
    {
      return true;
    }
  }, {
    key: "_getField",
    value: function _getField(name) {
      return this._fields.get(name);
    }
  }, {
    key: "_removeFieldByName",
    value: function _removeFieldByName(name) {
      return this._fields.delete(name);
    }
  }, {
    key: "_onFieldCreated",
    value: function _onFieldCreated(field
    /*, onDelete */
    ) {
      var _this2 = this;

      field.on('value', function (value) {
        _this2._calcValue();
      });
    }
  }, {
    key: "_getNextFieldName",
    value: function _getNextFieldName() {
      return this._nextFieldName++;
    }
  }, {
    key: "_handleDirtyFactory",
    value: function _handleDirtyFactory() {
      var _this3 = this;

      return function (dirty) {
        // Bubble up dirty event
        if (dirty) {
          _this3.set({
            dirty: true
          });
        }
      };
    }
  }, {
    key: "createField",
    value: function createField() {
      var _this4 = this;

      var name = this._getNextFieldName();

      var field = this._newField(name);

      var onDelete = function onDelete() {
        _this4._removeField(field);
      };

      field.on('delete', onDelete);
      field.on('dirty', this._handleDirtyFactory());

      this._onFieldCreated(field, onDelete);

      this._addField(field, name);

      return field;
    }
  }, {
    key: "_getOrCreateField",
    value: function _getOrCreateField(name) {
      if (!this._hasField(name)) {
        return this.createField();
      } else {
        return this._getField(name);
      }
    }
  }, {
    key: "_calcValue",
    value: function _calcValue() {
      // The field is now dirty. We emit this before emitting the value as we want the parent to have
      // a chance to be dirtied so that an auto validation has a chance to fire a canSubmit event.
      this.set({
        dirty: true
      }); // Instead of calling setValue(), we set the value directly and then emit an event. This
      // prevents an inifinite loop that would otherwise occur where the setValue() at this layer
      // triggers a setValue() on the child field, triggering a value event on the child field and
      // then back to this layer to cause an inifinite echo. We need to iterate through the entire
      // list each time as the user may have cleared an item.
      //
      // this.setValue(this._getValue());

      this._value = this._getValue();
      this.emitChange('value', this._value);
    }
  }, {
    key: "_listenForChangesToField",
    value: function _listenForChangesToField(field) {
      this._bubbleUpTouches(field);
    }
  }, {
    key: "_isLastField",
    value: function _isLastField(field) {
      return field.get('name') === this._fields.lastKey();
    }
  }, {
    key: "_cleanUpNextFields",
    value: function _cleanUpNextFields(afterName) {
      var nextName = afterName === null ? this._fields.firstKey() : this._fields.nextKey(afterName);

      if (nextName !== null) {
        var first = true;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this._fields.values(nextName)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var field = _step.value;

            if (first || !this._shouldRemoveField(field)) {
              field.clearValue();
              first = false;
            } else {
              this._removeField(field);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }
  }, {
    key: "_validateValueType",
    value: function _validateValueType(value) {
      var hasError = false;

      if (value === null || Array.isArray(value) || this.get('allowScalar')) {// No error
      } else {
        hasError = true;
      }

      this._hasTypeError = hasError;
    }
  }, {
    key: "_setValue",
    value: function _setValue(value) {
      var _this5 = this;

      (0, _get2.default)((0, _getPrototypeOf2.default)(ListField.prototype), "_setValue", this).call(this, value);

      this._validateValueType(value);

      var name = null;

      if (!this._hasTypeError) {
        var fields = this._fields.values();

        var values = null;

        if (Array.isArray(value)) {
          values = value;
        } else if (this.get('allowScalar')) {
          values = [value];
        }

        if (values !== null) {
          values.forEach(function (val) {
            var field = fields.next().value;

            if (!field) {
              field = _this5.createField();
            }

            field.setValue(val);
            name = field.get('name');
          });
        }
      }

      this._cleanUpNextFields(name);
    }
  }, {
    key: "_setDirty",
    value: function _setDirty(dirty) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(ListField.prototype), "_setDirty", this).call(this, dirty);
      this.eachField(function (field) {
        return field.set({
          dirty: dirty
        });
      });
    }
  }, {
    key: "setTouched",
    value: function setTouched(touched) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(ListField.prototype), "setTouched", this).call(this, touched);
      this.eachField(function (field) {
        return field.setTouched(touched);
      });
    }
  }, {
    key: "set",
    value: function set(props) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(ListField.prototype), "set", this).call(this, props);

      if (props.block !== undefined) {
        this.eachField(function (field) {
          return field.set({
            block: props.block
          });
        });
      }
    }
  }, {
    key: "validate",
    value: function validate() {
      this.clearErr();
      (0, _get2.default)((0, _getPrototypeOf2.default)(ListField.prototype), "validate", this).call(this);
      var errors = [];

      if (this._hasTypeError) {
        errors.push({
          error: 'must be an array'
        });
      } else {
        // We only want to proceed to validate the fields after we know there is no type error as type
        // errors can result in field errors and we want to report the root issue.
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this._fields.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var field = _step2.value;
            field.validate();

            if (field.hasErr()) {
              errors.push({
                field: field.get('name'),
                error: field.getErr()
              });
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var value = this.getValue(); // We use value and not isBlank() as the values can be out of sync

        if (value) {
          var minSize = this.get('minSize');
          var maxSize = this.get('maxSize');

          if (minSize !== null && value.length < minSize) {
            errors.push({
              error: "".concat(minSize, " or more")
            });
          } else if (maxSize !== null && value.length > maxSize) {
            errors.push({
              error: "".concat(maxSize, " or less")
            });
          }
        } // TODO: forbidDuplicates

      }

      if (errors.length > 0) {
        this.setErr(errors);
      }
    }
  }, {
    key: "canAddMoreFields",
    value: function canAddMoreFields(fieldValue) {
      var maxSize = this.get('maxSize');
      var value = this.getValue();
      var length = value ? value.length : 0; // If the fieldValue is truthy then consider this an addition so we have one more field than
      // currently exists

      if (fieldValue) {
        length++;
      }

      if (maxSize !== null && value && length >= maxSize) {
        return false;
      } else {
        return true;
      }
    }
  }, {
    key: "produce",
    value: function produce() {
      // Note: a previous design cloned an instance of a field to generate a new field. Cloning a
      // field is VERY slow, it requires a recursive dive into the instance because the original class
      // structure isn't immediately recoverable once a class has been instantiated. Instead, it is
      // much faster to generate a field via a factory. In addition, the clone method leads to race
      // conditions such as where the the didCreate event is never fired on a sub field of the cloned
      // field.
      var factory = this.get('fieldFactory');
      return factory.produce();
    }
  }, {
    key: "_newField",
    value: function _newField(index) {
      var field = this.produce();
      field.set((0, _objectSpread2.default)({
        name: index
      }, this.get(['required', 'block', 'fullWidth', 'useDisplayValue', 'editable'])));
      return field;
    }
  }, {
    key: "_clearFields",
    value: function _clearFields() {
      this._fields.clear();

      this._nextFieldName = 0;
    }
  }, {
    key: "getSingularLabel",
    value: function getSingularLabel() {
      if (this.get('singularLabel')) {
        return this.get('singularLabel');
      } else if (this.get('label')) {
        return _utils.default.toSingular(this.get('label'));
      } else {
        return null;
      }
    }
  }]);
  return ListField;
}(_compositeField.default);

exports.default = ListField;