"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _listField = _interopRequireDefault(require("./list-field"));

var _hierarchy = _interopRequireDefault(require("../hierarchy"));

var _selectField = _interopRequireDefault(require("./select-field"));

// TODO:
// - Option to require that a leaf node is selected?
// - Validation should make sure hierarchy is valid
// "options": [
//   { "value": "germany", "label": "Germany" },
//   { "value": "bmw", "label": "BMW", "parentValue": "germany" },
//   { "value": "m3", "label": "m3", "parentValue": "bmw" },
//   { "value": "i3", "label": "i3", "parentValue": "bmw" }
// ]
var ChainedSelectField =
/*#__PURE__*/
function (_ListField) {
  (0, _inherits2.default)(ChainedSelectField, _ListField);

  function ChainedSelectField() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, ChainedSelectField);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(ChainedSelectField)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_className", 'ChainedSelectField');
    return _this;
  }

  (0, _createClass2.default)(ChainedSelectField, [{
    key: "_create",
    value: function _create(props) {
      (0, _get2.default)((0, _getPrototypeOf3.default)(ChainedSelectField.prototype), "_create", this).call(this, props);
      this.set({
        schema: {
          component: 'Form',
          fields: [{
            name: 'fieldFactory',
            required: false
          }, {
            name: 'options',
            component: 'ChainedSelectOptionsField',
            docLevel: 'basic'
          }, {
            name: 'blankString',
            component: 'TextField'
          }, {
            name: 'multiline',
            component: 'BooleanField'
          }]
        }
      });

      this._setDefaults(props, {
        autoCreateFields: true,
        startWithField: false
      });
    }
  }, {
    key: "_getValue",
    value: function _getValue() {
      // Go all the way down the chain until nothing selected
      var value = [];
      this.eachField(function (field) {
        var val = field.getValue();

        if (val) {
          value.push(val);
        } else {
          // Exit loop prematurely
          return false;
        }
      });
      return value.length > 0 ? value : null;
    }
  }, {
    key: "_newField",
    value: function _newField(index) {
      return new _selectField.default((0, _objectSpread2.default)({
        name: index,
        label: index === 0 ? this.get('label') : undefined,
        required: index === 0 ? this.get('required') : undefined,
        block: !!this.get('multiline'),
        autoHideLabel: false,
        autocomplete: false
      }, this.get(['blankString', 'fullWidth', 'hideLabel', 'useDisplayValue', 'editable'])));
    }
  }, {
    key: "_onFieldCreated",
    value: function _onFieldCreated(field, onDelete) {
      var _this2 = this;

      field.on('value', function (value) {
        var index = field.get('name');

        if (value) {
          // Set options for next field
          _this2._setFieldOptions(field.getValue(), index + 1); // Clear the next field


          _this2._clearFieldIfExists(index + 1); // Clear any fields after the next field


          _this2._clearAndHideNextFieldsIfExist(index + 2);
        } else {
          // Clear any fields after this field
          _this2._clearAndHideNextFieldsIfExist(index + 1);
        }

        _this2._calcValue();
      });
    }
  }, {
    key: "_getChildOptions",
    value: function _getChildOptions(value, index) {
      // The parentValue can only be null if the index is 0 or else we will get the root options when
      // it is not intended.
      // if (value !== null || index === 0) {
      return this._indexedOptions.mapByParent(value, function (option) {
        return {
          value: option.id,
          label: option.label
        };
      }); // } else {
      //   return [];
      // }
    }
  }, {
    key: "_setFieldOptions",
    value: function _setFieldOptions(value, index) {
      var childOptions = this._getChildOptions(value, index); // Are there child options? i.e. the hierarchy continues down another layer


      if (childOptions.length > 0) {
        var field = this._getOrCreateField(index);

        field.set({
          options: childOptions
        }); // Show field if hidden

        field.set({
          hidden: false
        });
      }
    }
  }, {
    key: "_clearAndHideNextFieldsIfExist",
    value: function _clearAndHideNextFieldsIfExist(index) {
      if (this._hasField(index)) {
        var field = this._getField(index);

        field.clearValue();
        field.set({
          hidden: true
        });

        this._clearAndHideNextFieldsIfExist(index + 1);
      }
    }
  }, {
    key: "_cleanUpNextFields",
    value: function _cleanUpNextFields(index, value) {
      // Still on first field?
      if (index === null) {
        // Clear the first field as this will then adjust the subsequent fields
        this._fields.first().clearValue();
      }
    }
  }, {
    key: "_indexOptions",
    value: function _indexOptions(options) {
      var _this3 = this;

      this._indexedOptions = new _hierarchy.default();
      options.forEach(function (option) {
        _this3._indexedOptions.add({
          id: option.value,
          parentId: option.parentValue,
          label: option.label
        });
      });
    }
  }, {
    key: "_setOptions",
    value: function _setOptions(options) {
      this._indexOptions(options); // Set the options for the first field


      this._setFieldOptions(null, 0); // Clear the 2nd field


      this._clearFieldIfExists(1);
    }
  }, {
    key: "set",
    value: function set(props) {
      (0, _get2.default)((0, _getPrototypeOf3.default)(ChainedSelectField.prototype), "set", this).call(this, props);

      if (props.options !== undefined) {
        this._setOptions(props.options);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      var clonedField = (0, _get2.default)((0, _getPrototypeOf3.default)(ChainedSelectField.prototype), "clone", this).call(this); // Clear the fields as the listeners now have the wrong references to the fields, etc...

      clonedField._fields.clear(); // Create the first field


      clonedField._setOptions(this.get('options')); // Copy any existing value


      clonedField.setValue(this.getValue());
      return clonedField;
    }
  }]);
  return ChainedSelectField;
}(_listField.default);

exports.default = ChainedSelectField;