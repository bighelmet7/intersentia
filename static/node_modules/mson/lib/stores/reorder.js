"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Reorder = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

// Does a single pass of all the items, moving an item and reordering any items that need to be
// reordered. We iterate through all the items to provide fault tolerance against race conditions.
// Typically, items won't be moving too far so race conditions should be infrequent. Moving an item
// from the top of the list, including archiving an item, does require updating all items.
var Reorder =
/*#__PURE__*/
function () {
  function Reorder() {
    (0, _classCallCheck2.default)(this, Reorder);
  }

  (0, _createClass2.default)(Reorder, [{
    key: "_handleReorder",
    // We use a value of -1 instead of null as you cannot paginate a SQL DB with null values, i.e.
    // `WHERE order>NULL` does not work in this way.
    value: function _handleReorder(item, newOrder, onReorder) {
      if (item.order !== newOrder) {
        return onReorder(item, newOrder);
      }
    }
  }, {
    key: "reorderItem",
    value: function reorderItem(item, id, newOrder, i, destinationKey, onReorder) {
      var afterReordered = null;

      if (i === newOrder && newOrder !== this.constructor.DEFAULT_ORDER) {
        // We have reached the new order so skip this i as it will be used by the item being moved
        i++;
        destinationKey = item.id;
      }

      if (item.id === id) {
        // This item is the target item so reorder it
        afterReordered = this._handleReorder(item, newOrder, onReorder);
      } else if (item.order !== this.constructor.DEFAULT_ORDER || !item.archivedAt) {
        // We inspect archivedAt because we want to be able to turn on ordering at any time
        // Set the order based on the current i
        afterReordered = this._handleReorder(item, i, onReorder);
        i++;
      }

      return {
        i: i,
        destinationKey: destinationKey,
        afterReordered: afterReordered
      };
    }
  }, {
    key: "reorder",
    value: function reorder(items, id, newOrder, onReorder) {
      var _this = this;

      var i = 0;
      var destinationKey = null;
      items.forEach(function (item) {
        var result = _this.reorderItem(item, id, newOrder, i, destinationKey, onReorder);

        i = result.i;
        destinationKey = result.destinationKey;
      });
      return {
        destinationKey: destinationKey
      };
    }
  }]);
  return Reorder;
}();

exports.Reorder = Reorder;
(0, _defineProperty2.default)(Reorder, "DEFAULT_ORDER", -1);

var _default = new Reorder();

exports.default = _default;