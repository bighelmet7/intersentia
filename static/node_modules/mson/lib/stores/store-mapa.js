"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _mapa = _interopRequireDefault(require("../mapa"));

var _reorder2 = _interopRequireWildcard(require("./reorder"));

// Dynamically moves the docs when the order is adjusted
var StoreMapa =
/*#__PURE__*/
function (_Mapa) {
  (0, _inherits2.default)(StoreMapa, _Mapa);

  function StoreMapa() {
    (0, _classCallCheck2.default)(this, StoreMapa);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(StoreMapa).apply(this, arguments));
  }

  (0, _createClass2.default)(StoreMapa, [{
    key: "_getProp",
    value: function _getProp(doc, name) {
      return doc[name];
    }
  }, {
    key: "_setProp",
    value: function _setProp(doc, name, value) {
      return doc[name] = value;
    } // FUTURE: for small data sets, the only ones we expect to use with the ordering, it is relatively
    // quick to iterate through the items to find where to insert an item. If a speed increase is
    // needed, we could use a b-tree to find the correct place in logrithmic time.

  }, {
    key: "_findIdAfter",
    value: function _findIdAfter(order) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var entry = _step.value;

          var entryOrder = this._getProp(entry[1], 'order');

          if (entryOrder === undefined || entryOrder === null || entryOrder > order) {
            return entry[0];
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return null;
    }
  }, {
    key: "getBeforeId",
    value: function getBeforeId(doc) {
      if (this._getProp(doc, 'archivedAt')) {
        // Move to last
        return null;
      } else if (this._getProp(doc, 'order') === null || this._getProp(doc, 'order') === undefined) {
        // The order is unspecified
        return undefined;
      } else {
        // Iterate over the list to find the correct place to insert the new doc
        return this._findIdAfter(this._getProp(doc, 'order'));
      }
    }
  }, {
    key: "_createInDocs",
    value: function _createInDocs(id, doc) {
      var beforeId = this.getBeforeId(doc);
      return (0, _get2.default)((0, _getPrototypeOf2.default)(StoreMapa.prototype), "set", this).call(this, id, doc, beforeId);
    }
  }, {
    key: "_createInDocsAndReorder",
    value: function _createInDocsAndReorder(id, doc, onReorder) {
      // Note: we don't inject `order=length() - 1` as we want the caller to be able to:
      // - Disable reordering by not specifying an order
      // - Set the order of the new item
      var order = this._getProp(doc, 'order');

      if (order === _reorder2.Reorder.DEFAULT_ORDER || order === undefined) {
        // Just create the doc as there is no order so we don't need to incur any extra overhead in
        // reordering
        return this._createInDocs(id, doc);
      } else {
        return this._reorder(id, doc, order, onReorder);
      }
    }
  }, {
    key: "_updateInDocs",
    value: function _updateInDocs(id, doc) {
      var beforeId = undefined;
      var existingDoc = this.get(id); // Is the order changing?

      if (this._getProp(doc, 'order') !== this._getProp(existingDoc, 'order')) {
        beforeId = this.getBeforeId(doc);
      }

      return (0, _get2.default)((0, _getPrototypeOf2.default)(StoreMapa.prototype), "set", this).call(this, id, doc, beforeId);
    }
  }, {
    key: "keysAtIndexes",
    value: function keysAtIndexes(indexes) {
      var clonedIndexes = Object.assign([], indexes);
      var index = 0;
      var keys = {};
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var entry = _step2.value;
          var i = clonedIndexes.indexOf(index);

          if (i !== -1) {
            keys[clonedIndexes[i]] = entry[0];

            if (clonedIndexes.length === 1) {
              // Exit loop as we found what we need
              break;
            } else {
              clonedIndexes.splice(i, 1);
            }
          }

          index++;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return keys;
    }
  }, {
    key: "_reorder",
    value: function _reorder(id, item, newOrder, onReorder) {
      var _this = this;

      var items = {
        forEach: function forEach(callback) {
          _this.forEach(function (item, id) {
            callback({
              id: id,
              order: _this._getProp(item, 'order'),
              archivedAt: _this._getProp(item, 'archivedAt')
            });
          });
        }
      };

      var handleReorder = function handleReorder(item, newOrder) {
        var itemId = _this._getProp(item, 'id'); // Make sure this is not the target item. We'll update the target item below once we've found
        // the destinationKey. We may need to iterate through all the items just to find the
        // destinationKey.


        if (itemId !== id) {
          var doc = _this.get(itemId);

          _this._setProp(doc, 'order', newOrder);

          (0, _get2.default)((0, _getPrototypeOf2.default)(StoreMapa.prototype), "set", _this).call(_this, itemId, doc);

          if (onReorder) {
            onReorder(itemId, doc);
          }
        }
      };

      var result = _reorder2.default.reorder(items, id, newOrder, handleReorder);

      this._setProp(item, 'order', newOrder);

      return (0, _get2.default)((0, _getPrototypeOf2.default)(StoreMapa.prototype), "set", this).call(this, id, item, result.destinationKey);
    }
  }, {
    key: "_updateInDocsAndReorder",
    value: function _updateInDocsAndReorder(id, doc, onReorder) {
      var existingDoc = this.get(id);

      var existingOrder = this._getProp(existingDoc, 'order');

      var newOrder = this._getProp(doc, 'order');

      if (existingOrder === newOrder) {
        // Just update the doc as the order isn't changing so we don't need to incur any extra
        // overhead in reordering
        return this._updateInDocs(id, doc);
      } else {
        return this._reorder(id, doc, newOrder, onReorder);
      }
    }
  }, {
    key: "set",
    value: function set(id, doc, beforeId, afterId, reorder, onReorder) {
      if (beforeId !== undefined || afterId !== undefined) {
        return (0, _get2.default)((0, _getPrototypeOf2.default)(StoreMapa.prototype), "set", this).call(this, id, doc, beforeId, afterId);
      } else if (this.has(id)) {
        if (reorder) {
          return this._updateInDocsAndReorder(id, doc, onReorder);
        } else {
          return this._updateInDocs(id, doc);
        }
      } else {
        if (reorder) {
          return this._createInDocsAndReorder(id, doc, onReorder);
        } else {
          return this._createInDocs(id, doc);
        }
      }
    }
  }]);
  return StoreMapa;
}(_mapa.default);

exports.default = StoreMapa;