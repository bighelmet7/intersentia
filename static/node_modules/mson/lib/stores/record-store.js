"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _store = _interopRequireDefault(require("./store"));

var _utils = _interopRequireDefault(require("../utils"));

var _uberUtils = _interopRequireDefault(require("../uber-utils"));

var _registrar = _interopRequireDefault(require("../compiler/registrar"));

var _reorder3 = _interopRequireWildcard(require("./reorder"));

// TODO: make changes real time with subscriptions
var RecordStore =
/*#__PURE__*/
function (_Store) {
  (0, _inherits2.default)(RecordStore, _Store);

  function RecordStore() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, RecordStore);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(RecordStore)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_className", 'RecordStore');
    return _this;
  }

  (0, _createClass2.default)(RecordStore, [{
    key: "_create",
    value: function _create(props) {
      (0, _get2.default)((0, _getPrototypeOf3.default)(RecordStore.prototype), "_create", this).call(this, props); // For mocking

      this._uberUtils = _uberUtils.default;
      this._registrar = _registrar.default;
      this.set({
        schema: {
          component: 'Form',
          fields: [{
            name: 'storeName',
            component: 'TextField',
            required: true
          }]
        }
      });
    }
  }, {
    key: "set",
    value: function set(props) {
      (0, _get2.default)((0, _getPrototypeOf3.default)(RecordStore.prototype), "set", this).call(this, props);

      this._clearCache();
    }
  }, {
    key: "_tryAndHandleError",
    value: function () {
      var _tryAndHandleError2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(promiseFactory) {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", promiseFactory());

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function _tryAndHandleError(_x) {
        return _tryAndHandleError2.apply(this, arguments);
      }

      return _tryAndHandleError;
    }()
  }, {
    key: "_request",
    value: function () {
      var _request2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2(_ref) {
        var form, promiseFactory, appId;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                form = _ref.form, promiseFactory = _ref.promiseFactory;
                appId = this._globals.get('appId');
                _context2.prev = 2;
                _context2.next = 5;
                return promiseFactory(appId);

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](2);

                if (form) {
                  this._uberUtils.setFormErrorsFromAPIError(_context2.t0, form);
                } else {
                  this._uberUtils.displayError(_context2.t0.toString());
                } // We throw the error so that the entire listener chain is aborted


                throw _context2.t0;

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[2, 8]]);
      }));

      function _request(_x2) {
        return _request2.apply(this, arguments);
      }

      return _request;
    }()
  }, {
    key: "_createDoc",
    value: function () {
      var _createDoc2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3(_ref2) {
        var _this2 = this;

        var form, fieldValues, order, reorder, result, response;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                form = _ref2.form, fieldValues = _ref2.fieldValues, order = _ref2.order, reorder = _ref2.reorder;

                this._clearCache();

                if (!this._shouldSetToLastOrder(order, reorder)) {
                  _context3.next = 8;
                  break;
                }

                _context3.next = 5;
                return this._reorder({
                  form: form
                });

              case 5:
                result = _context3.sent;
                order = result.lastOrder;
                fieldValues = Object.assign({}, fieldValues, {
                  order: order
                });

              case 8:
                _context3.next = 10;
                return this._request({
                  form: form,
                  promiseFactory: function promiseFactory(appId) {
                    return _this2._registrar.client.record.create({
                      appId: appId,
                      componentName: _this2.get('storeName'),
                      fieldValues: fieldValues,
                      order: order
                    });
                  }
                });

              case 10:
                response = _context3.sent;
                return _context3.abrupt("return", response.data.createRecord);

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _createDoc(_x3) {
        return _createDoc2.apply(this, arguments);
      }

      return _createDoc;
    }()
  }, {
    key: "_clearCache",
    value: function _clearCache() {
      this._cachedQueries = {};
    }
  }, {
    key: "_inCache",
    value: function _inCache(opts) {
      return this._cachedQueries[JSON.stringify(opts)] ? true : false;
    }
  }, {
    key: "_addToCache",
    value: function _addToCache(opts) {
      this._cachedQueries[JSON.stringify(opts)] = true;
    }
  }, {
    key: "_getShowArchivedWhere",
    value: function _getShowArchivedWhere(showArchived) {
      if (showArchived === null) {
        return null;
      } else if (showArchived) {
        return {
          archivedAt: {
            $ne: null
          }
        };
      } else {
        return {
          archivedAt: null
        };
      }
    }
  }, {
    key: "_getAllDocs",
    value: function () {
      var _getAllDocs2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee5(_ref3) {
        var _this3 = this;

        var form, where, showArchived, after, first, before, last, order, showArchivedWhere;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                form = _ref3.form, where = _ref3.where, showArchived = _ref3.showArchived, after = _ref3.after, first = _ref3.first, before = _ref3.before, last = _ref3.last, order = _ref3.order;
                showArchivedWhere = this._getShowArchivedWhere(showArchived);
                where = _utils.default.combineWheres(showArchivedWhere, where, this.get('where'));
                return _context5.abrupt("return", this._request({
                  form: form,
                  promiseFactory: function () {
                    var _promiseFactory = (0, _asyncToGenerator2.default)(
                    /*#__PURE__*/
                    _regenerator.default.mark(function _callee4(appId) {
                      var opts, response;
                      return _regenerator.default.wrap(function _callee4$(_context4) {
                        while (1) {
                          switch (_context4.prev = _context4.next) {
                            case 0:
                              opts = {
                                appId: appId,
                                componentName: _this3.get('storeName'),
                                asArray: true,
                                where: where,
                                after: after,
                                first: first,
                                before: before,
                                last: last,
                                order: order
                              }; // The built-in apollo client cache cannot automatically accomodate the mutations so we use a
                              // thin layer on top to clear the cache (invalidate it) when it needs to be rebuilt. In
                              // particular this is needed when archiving/restoring and then toggling showArchived. TODO: is
                              // there a better way? Using readQuery and writeQuery at the ApolloClient layer doesn't appear
                              // to fix this issue.

                              if (!_this3._inCache(opts)) {
                                _this3._addToCache(opts);

                                opts.bypassCache = true;
                              }

                              _context4.next = 4;
                              return _this3._registrar.client.record.getAll(opts);

                            case 4:
                              response = _context4.sent;
                              return _context4.abrupt("return", response.data.records);

                            case 6:
                            case "end":
                              return _context4.stop();
                          }
                        }
                      }, _callee4);
                    }));

                    function promiseFactory(_x5) {
                      return _promiseFactory.apply(this, arguments);
                    }

                    return promiseFactory;
                  }()
                }));

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _getAllDocs(_x4) {
        return _getAllDocs2.apply(this, arguments);
      }

      return _getAllDocs;
    }()
  }, {
    key: "_reorder",
    value: function () {
      var _reorder2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee6(_ref4) {
        var form, id, order, loop, props, itemsToReorder, onReorder, i, destinationKey, response, j, item, result, _j, _itemsToReorder$_j, _id, _order, fieldValues;

        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                form = _ref4.form, id = _ref4.id, order = _ref4.order;
                loop = true;
                props = {
                  first: this.constructor.ITEMS_PER_PAGE_DEFAULT,
                  order: [['order', 'asc']],
                  where: this.get('where')
                };
                itemsToReorder = [];

                onReorder = function onReorder(item, newOrder) {
                  // Only reorder the affected items. The item being moved will be updated afterwards
                  if (item.id !== id) {
                    itemsToReorder.push({
                      id: item.id,
                      order: newOrder
                    });
                  }
                };

                i = 0;
                destinationKey = null;

              case 7:
                if (!loop) {
                  _context6.next = 16;
                  break;
                }

                _context6.next = 10;
                return this.getAllDocs(props);

              case 10:
                response = _context6.sent;

                for (j = 0; j < response.edges.length; j++) {
                  item = response.edges[j];
                  result = _reorder3.default.reorderItem(item.node, id, order, i, destinationKey, onReorder);
                  i = result.i;
                  destinationKey = result.destinationKey;
                }

                props.after = response.pageInfo.endCursor;
                loop = response.pageInfo.hasNextPage;
                _context6.next = 7;
                break;

              case 16:
                if (!(itemsToReorder.length > 0)) {
                  _context6.next = 27;
                  break;
                }

                // We have to clear the cache as the order of the items has changed.
                this._clearCache(); // We have to update the items after we get them all or else our updates can affect the order the
                // pagination results


                _j = 0;

              case 19:
                if (!(_j < itemsToReorder.length)) {
                  _context6.next = 27;
                  break;
                }

                _itemsToReorder$_j = itemsToReorder[_j], _id = _itemsToReorder$_j.id, _order = _itemsToReorder$_j.order; // Set to blank as we are using partial updates and don't need to send all the data

                fieldValues = {};
                _context6.next = 24;
                return this._requestUpdate({
                  form: form,
                  id: _id,
                  order: _order,
                  fieldValues: fieldValues
                });

              case 24:
                _j++;
                _context6.next = 19;
                break;

              case 27:
                return _context6.abrupt("return", {
                  lastOrder: i
                });

              case 28:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _reorder(_x6) {
        return _reorder2.apply(this, arguments);
      }

      return _reorder;
    }()
  }, {
    key: "_requestUpdate",
    value: function () {
      var _requestUpdate2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee7(_ref5) {
        var _this4 = this;

        var form, id, fieldValues, order, response;
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                form = _ref5.form, id = _ref5.id, fieldValues = _ref5.fieldValues, order = _ref5.order;
                _context7.next = 3;
                return this._request({
                  form: form,
                  promiseFactory: function promiseFactory(appId) {
                    return _this4._registrar.client.record.update({
                      appId: appId,
                      componentName: _this4.get('storeName'),
                      id: id,
                      fieldValues: fieldValues,
                      order: order
                    });
                  }
                });

              case 3:
                response = _context7.sent;
                return _context7.abrupt("return", response.data.updateRecord);

              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _requestUpdate(_x7) {
        return _requestUpdate2.apply(this, arguments);
      }

      return _requestUpdate;
    }()
  }, {
    key: "_updateDoc",
    value: function () {
      var _updateDoc2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee8(_ref6) {
        var form, id, fieldValues, order, reorder;
        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                form = _ref6.form, id = _ref6.id, fieldValues = _ref6.fieldValues, order = _ref6.order, reorder = _ref6.reorder;

                if (!reorder) {
                  _context8.next = 4;
                  break;
                }

                _context8.next = 4;
                return this._reorder({
                  form: form,
                  id: id,
                  order: order
                });

              case 4:
                return _context8.abrupt("return", this._requestUpdate({
                  form: form,
                  id: id,
                  fieldValues: fieldValues,
                  order: order
                }));

              case 5:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _updateDoc(_x8) {
        return _updateDoc2.apply(this, arguments);
      }

      return _updateDoc;
    }()
  }, {
    key: "_getDoc",
    value: function () {
      var _getDoc2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee9(_ref7) {
        var _this5 = this;

        var form, id, where, response;
        return _regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                form = _ref7.form, id = _ref7.id, where = _ref7.where;
                _context9.next = 3;
                return this._request({
                  form: form,
                  promiseFactory: function promiseFactory(appId) {
                    return _this5._registrar.client.record.get({
                      appId: appId,
                      componentName: _this5.get('storeName'),
                      id: id,
                      where: where
                    });
                  }
                });

              case 3:
                response = _context9.sent;
                return _context9.abrupt("return", response.data.record);

              case 5:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function _getDoc(_x9) {
        return _getDoc2.apply(this, arguments);
      }

      return _getDoc;
    }()
  }, {
    key: "getDoc",
    value: function () {
      var _getDoc3 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee10(props) {
        return _regenerator.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                return _context10.abrupt("return", this._getDoc(props));

              case 1:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getDoc(_x10) {
        return _getDoc3.apply(this, arguments);
      }

      return getDoc;
    }() // TODO: refactor out after upsert is supported by API. Note: this is not a high priority as the
    // cache keeps us from hitting the API in many cases.

  }, {
    key: "_upsertDoc",
    value: function () {
      var _upsertDoc2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee11(props) {
        var id, exists;
        return _regenerator.default.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                id = props.id;
                exists = false;

                if (!id) {
                  _context11.next = 15;
                  break;
                }

                _context11.prev = 3;
                _context11.next = 6;
                return this._getDoc({
                  id: id
                });

              case 6:
                exists = true;
                _context11.next = 15;
                break;

              case 9:
                _context11.prev = 9;
                _context11.t0 = _context11["catch"](3);

                if (!(_context11.t0.message === 'GraphQL error: record not found')) {
                  _context11.next = 14;
                  break;
                }

                _context11.next = 15;
                break;

              case 14:
                throw _context11.t0;

              case 15:
                if (!exists) {
                  _context11.next = 19;
                  break;
                }

                return _context11.abrupt("return", this.updateDoc(props));

              case 19:
                return _context11.abrupt("return", this.createDoc(props));

              case 20:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this, [[3, 9]]);
      }));

      function _upsertDoc(_x11) {
        return _upsertDoc2.apply(this, arguments);
      }

      return _upsertDoc;
    }()
  }, {
    key: "_archiveDoc",
    value: function () {
      var _archiveDoc2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee12(_ref8) {
        var _this6 = this;

        var form, id, reorder, response;
        return _regenerator.default.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                form = _ref8.form, id = _ref8.id, reorder = _ref8.reorder;

                this._clearCache();

                _context12.next = 4;
                return this._request({
                  form: form,
                  promiseFactory: function promiseFactory(appId) {
                    return _this6._registrar.client.record.archive({
                      appId: appId,
                      componentName: _this6.get('storeName'),
                      id: id
                    });
                  }
                });

              case 4:
                response = _context12.sent;

                if (reorder) {
                  // Remove from ordered list and reorder affected docs. TODO: should we refactor archive so
                  // that you can pass in values like order? This way, you can archive and reorder in a single
                  // call.
                  //
                  // TODO: we don't await the _updateDoc() here as it can take a while to reorder all the docs
                  // and we don't want it to take this long to confirm the deletion. Is there a better way? We
                  // could:
                  //   - Pass the where property to the back end so that the back end can perform the
                  //     reordering. Would this be fast enough? The back end would still have to iterate through
                  //     all the items.
                  //   - Support batch updates. I'm not clear how much faster this would be though as we are
                  //     already using web sockets and so there is less overhead per update.
                  //   - If we stick with this detached construct (no await) then we should probably report any
                  //     errors via an 'updateErr' event on the store
                  this._updateDoc({
                    form: form,
                    id: id,
                    order: _reorder3.Reorder.DEFAULT_ORDER,
                    reorder: true,
                    fieldValues: {}
                  });
                }

                return _context12.abrupt("return", response.data.archiveRecord);

              case 7:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function _archiveDoc(_x12) {
        return _archiveDoc2.apply(this, arguments);
      }

      return _archiveDoc;
    }()
  }, {
    key: "_restoreDoc",
    value: function () {
      var _restoreDoc2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee13(_ref9) {
        var _this7 = this;

        var form, id, order, reorder, response, result;
        return _regenerator.default.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                form = _ref9.form, id = _ref9.id, order = _ref9.order, reorder = _ref9.reorder;

                this._clearCache();

                _context13.next = 4;
                return this._request({
                  form: form,
                  promiseFactory: function promiseFactory(appId) {
                    return _this7._registrar.client.record.restore({
                      appId: appId,
                      componentName: _this7.get('storeName'),
                      id: id
                    });
                  }
                });

              case 4:
                response = _context13.sent;

                if (!this._shouldSetToLastOrder(order, reorder)) {
                  _context13.next = 11;
                  break;
                }

                _context13.next = 8;
                return this._reorder({
                  form: form,
                  id: id
                });

              case 8:
                result = _context13.sent;
                _context13.next = 11;
                return this._updateDoc({
                  form: form,
                  id: id,
                  fieldValues: {},
                  order: result.lastOrder,
                  reorder: false
                });

              case 11:
                return _context13.abrupt("return", response.data.restoreRecord);

              case 12:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function _restoreDoc(_x13) {
        return _restoreDoc2.apply(this, arguments);
      }

      return _restoreDoc;
    }()
  }]);
  return RecordStore;
}(_store.default);

exports.default = RecordStore;
(0, _defineProperty2.default)(RecordStore, "ITEMS_PER_PAGE_DEFAULT", 50);