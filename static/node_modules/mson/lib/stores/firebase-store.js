"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _memoryStore = _interopRequireDefault(require("./memory-store"));

var _cloneDeep = _interopRequireDefault(require("lodash/cloneDeep"));

var _reorder = require("./reorder");

// NOTE: Firebase doesn't support complex quering like most DBs (
// https://firebase.google.com/docs/firestore/query-data/queries). Therefore, we will do all the
// querying in memory. In the future we may want to support a minimal set of queries against the
// firestore DB so that we have the option of working with larger datasets.
var FirebaseStore =
/*#__PURE__*/
function (_MemoryStore) {
  (0, _inherits2.default)(FirebaseStore, _MemoryStore);

  function FirebaseStore() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, FirebaseStore);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(FirebaseStore)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_className", 'FirebaseStore');
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_onReorder",
    /*#__PURE__*/
    function () {
      var _ref = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(id, doc) {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this._docSet({
                  id: id,
                  doc: doc,
                  options: {
                    merge: true // allow for partial updates

                  }
                });

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }());
    return _this;
  }

  (0, _createClass2.default)(FirebaseStore, [{
    key: "_listenToChanges",
    // React to real-time changes made remotely
    value: function () {
      var _listenToChanges2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2() {
        var _this2 = this;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                // We order by createdAt as per https://firebase.google.com/docs/firestore/manage-data/add-data,
                // "Firestore auto-generated IDs do not provide any automatic ordering. If you want to be able
                // to order your documents by creation date, you should store a timestamp as a field in the
                // documents." We can only order by a single attribute (unless we create an index) so we'll pick
                // the order.
                this._coll.orderBy('createdAt').onSnapshot(function (snapshot) {
                  snapshot.docChanges().forEach(function (change) {
                    var data = change.doc.data();

                    if (change.type === 'removed') {
                      _this2._docs.delete(data.id);
                    } else {
                      _this2._docs.set(data.id, data);
                    }
                  }); // First load?

                  if (!_this2.isLoaded()) {
                    // Emit on next tick so that caller has a change to listen
                    setTimeout(function () {
                      _this2._emitDidLoad();
                    });
                  }
                }, function (err) {
                  _this2._emitError(err);
                });

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _listenToChanges() {
        return _listenToChanges2.apply(this, arguments);
      }

      return _listenToChanges;
    }() // async _loadDocs() {
    //   const docs = await this._coll.get();
    //   docs.forEach(doc => {
    //     const doc = doc.data();
    //     this._docs.set(doc.id, doc);
    //   });
    // }

  }, {
    key: "_getFirebase",
    value: function _getFirebase(props) {
      return props.firebase ? props.firebase : this._global.firebase;
    }
  }, {
    key: "_initializeApp",
    value: function _initializeApp(props) {
      // Has Firebase been initialized? We must only do this once per app.
      if (!this._fb.apps.length) {
        this._fb.initializeApp({
          apiKey: props.apiKey,
          authDomain: props.authDomain,
          projectId: props.projectId
        });
      }
    }
  }, {
    key: "_init",
    value: function () {
      var _init2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3(props) {
        var settings;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this._fb = this._getFirebase(props);

                this._initializeApp(props);

                this._db = this._fb.firestore(); // Disable warning

                settings = {
                  timestampsInSnapshots: true
                };

                this._db.settings(settings);

                this._coll = this._db.collection(props.collection);

                this._listenToChanges(); // Not needed as we get the docs by listening to the changes
                // await this._loadDocs();


              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _init(_x3) {
        return _init2.apply(this, arguments);
      }

      return _init;
    }()
  }, {
    key: "_create",
    value: function _create(props) {
      (0, _get2.default)((0, _getPrototypeOf3.default)(FirebaseStore.prototype), "_create", this).call(this, Object.assign({}, props, {
        // Mute didLoad in the base classes as we need to emit didLoad after all the docs have been
        // loaded asynchronously
        muteDidLoad: true
      })); // For mocking

      this._global = global;
      this.set({
        schema: {
          component: 'Form',
          fields: [{
            // For mocking
            name: 'firebase',
            component: 'Field'
          }, {
            name: 'apiKey',
            component: 'TextField',
            required: true
          }, {
            name: 'authDomain',
            component: 'TextField',
            required: true
          }, {
            name: 'projectId',
            component: 'TextField',
            required: true
          }, {
            name: 'collection',
            component: 'TextField',
            required: true
          }]
        }
      }); // Don't actually connect to Firebase unless we specify an API Key

      if (props.apiKey !== undefined) {
        this._init(props);
      }
    }
  }, {
    key: "_docSet",
    value: function () {
      var _docSet2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee4(_ref2) {
        var id, doc, options;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                id = _ref2.id, doc = _ref2.doc, options = _ref2.options;

                if (!this.get('apiKey')) {
                  _context4.next = 4;
                  break;
                }

                // The Firebase API is not capable of storing undefined values so we remove them
                doc = JSON.parse(JSON.stringify(doc)); // Update the Firebase store

                return _context4.abrupt("return", this._coll.doc(id).set(doc, options));

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _docSet(_x4) {
        return _docSet2.apply(this, arguments);
      }

      return _docSet;
    }()
  }, {
    key: "_createDoc",
    value: function () {
      var _createDoc2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee5(_ref3) {
        var fieldValues, id, order, reorder, userId, doc;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                fieldValues = _ref3.fieldValues, id = _ref3.id, order = _ref3.order, reorder = _ref3.reorder;

                if (this._shouldSetToLastOrder(order, reorder)) {
                  order = this._numUnarchived();
                }

                userId = this._getUserId();
                doc = this._buildDoc({
                  fieldValues: fieldValues,
                  id: id,
                  order: order,
                  userId: userId
                }); // Note: we need to update the underlying MemoryStore so that the data is there after this
                // function completes even though Firebase will emit an onWrite with the changed data.

                this._docs.set(doc.id, doc, undefined, undefined, true, this._onReorder);

                _context5.next = 7;
                return this._docSet({
                  id: doc.id,
                  doc: doc,
                  order: doc.order
                });

              case 7:
                return _context5.abrupt("return", doc);

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _createDoc(_x5) {
        return _createDoc2.apply(this, arguments);
      }

      return _createDoc;
    }()
  }, {
    key: "_modifyDoc",
    value: function () {
      var _modifyDoc2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee6(_ref4) {
        var id, fieldValues, archivedAt, order, doc;
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                id = _ref4.id, fieldValues = _ref4.fieldValues, archivedAt = _ref4.archivedAt, order = _ref4.order;
                // We use cloneDeep so that we don't modify the data in the memory store before we modify the
                // data in the Firebase store. The write to Firebase could always fail.
                doc = (0, _cloneDeep.default)(this._docs.get(id));
                doc = this._setDoc({
                  doc: doc,
                  fieldValues: fieldValues,
                  archivedAt: archivedAt,
                  order: order
                }); // Note: we need to update the underlying MemoryStore so that the data is there after this
                // function completes even though Firebase will emit an onWrite with the changed data.

                this._docs.set(doc.id, doc, undefined, undefined, true, this._onReorder); // The value has to be set in Firebase after it is set in the mapa so that _docs.set() can
                // detect when there is a change to the order


                _context6.next = 6;
                return this._docSet({
                  id: doc.id,
                  doc: doc,
                  options: {
                    merge: true // allow for partial updates

                  }
                });

              case 6:
                return _context6.abrupt("return", doc);

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _modifyDoc(_x6) {
        return _modifyDoc2.apply(this, arguments);
      }

      return _modifyDoc;
    }()
  }, {
    key: "_updateDoc",
    value: function () {
      var _updateDoc2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee7(props) {
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                return _context7.abrupt("return", this._modifyDoc(props));

              case 1:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _updateDoc(_x7) {
        return _updateDoc2.apply(this, arguments);
      }

      return _updateDoc;
    }()
  }, {
    key: "_archiveDoc",
    value: function () {
      var _archiveDoc2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee8(props) {
        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                return _context8.abrupt("return", this._modifyDoc((0, _objectSpread2.default)({}, props, {
                  archivedAt: this._now(),
                  order: _reorder.Reorder.DEFAULT_ORDER
                })));

              case 1:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _archiveDoc(_x8) {
        return _archiveDoc2.apply(this, arguments);
      }

      return _archiveDoc;
    }()
  }, {
    key: "_restoreDoc",
    value: function () {
      var _restoreDoc2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee9(_ref5) {
        var reorder, order, props;
        return _regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                reorder = _ref5.reorder, order = _ref5.order, props = (0, _objectWithoutProperties2.default)(_ref5, ["reorder", "order"]);

                if (this._shouldSetToLastOrder(order, reorder)) {
                  order = this._numUnarchived();
                }

                return _context9.abrupt("return", this._modifyDoc((0, _objectSpread2.default)({}, props, {
                  archivedAt: null,
                  order: order
                })));

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function _restoreDoc(_x9) {
        return _restoreDoc2.apply(this, arguments);
      }

      return _restoreDoc;
    }()
  }, {
    key: "_waitForDataToBeLoaded",
    value: function () {
      var _waitForDataToBeLoaded2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee10() {
        return _regenerator.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.resolveAfterLoad();

              case 2:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function _waitForDataToBeLoaded() {
        return _waitForDataToBeLoaded2.apply(this, arguments);
      }

      return _waitForDataToBeLoaded;
    }()
  }, {
    key: "_getDoc",
    value: function () {
      var _getDoc2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee11(props) {
        return _regenerator.default.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this._waitForDataToBeLoaded();

              case 2:
                return _context11.abrupt("return", (0, _get2.default)((0, _getPrototypeOf3.default)(FirebaseStore.prototype), "_getDoc", this).call(this, props));

              case 3:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function _getDoc(_x10) {
        return _getDoc2.apply(this, arguments);
      }

      return _getDoc;
    }()
  }, {
    key: "_getAllDocs",
    value: function () {
      var _getAllDocs2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee12(props) {
        return _regenerator.default.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this._waitForDataToBeLoaded();

              case 2:
                return _context12.abrupt("return", (0, _get2.default)((0, _getPrototypeOf3.default)(FirebaseStore.prototype), "_getAllDocs", this).call(this, props));

              case 3:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function _getAllDocs(_x11) {
        return _getAllDocs2.apply(this, arguments);
      }

      return _getAllDocs;
    }()
  }]);
  return FirebaseStore;
}(_memoryStore.default);

exports.default = FirebaseStore;