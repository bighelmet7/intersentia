"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Utils = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _reduce = _interopRequireDefault(require("lodash/reduce"));

var _each = _interopRequireDefault(require("lodash/each"));

var _uuid2 = _interopRequireDefault(require("uuid"));

var Utils =
/*#__PURE__*/
function () {
  function Utils() {
    (0, _classCallCheck2.default)(this, Utils);
    // For mocking
    this._global = global;
  }

  (0, _createClass2.default)(Utils, [{
    key: "sequential",
    value: function () {
      var _sequential = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2(items, onItem) {
        var values;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                values = [];
                _context2.next = 3;
                return (0, _reduce.default)(items,
                /*#__PURE__*/
                function () {
                  var _ref = (0, _asyncToGenerator2.default)(
                  /*#__PURE__*/
                  _regenerator.default.mark(function _callee(promise, item, key) {
                    var value;
                    return _regenerator.default.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            _context.next = 2;
                            return promise;

                          case 2:
                            _context.next = 4;
                            return onItem(item, key);

                          case 4:
                            value = _context.sent;

                            if (value !== undefined) {
                              values.push(value);
                            }

                          case 6:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function (_x3, _x4, _x5) {
                    return _ref.apply(this, arguments);
                  };
                }(), Promise.resolve());

              case 3:
                return _context2.abrupt("return", values);

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function sequential(_x, _x2) {
        return _sequential.apply(this, arguments);
      }

      return sequential;
    }() // // A recursive merge that also concats arrays
    // merge(object, sources) {
    //   const mergeCustomizer = (objValue, srcValue) => {
    //     if (_.isArray(objValue)) {
    //       return objValue.concat(srcValue);
    //     }
    //   };
    //   return _.mergeWith(object, sources, mergeCustomizer);
    // }

  }, {
    key: "inBrowser",
    value: function inBrowser() {
      return !!this._global.window;
    } // Source: https://stackoverflow.com/a/40577337/2831606

  }, {
    key: "getAllMethodNames",
    value: function getAllMethodNames(obj) {
      var methods = [];

      while (obj = Reflect.getPrototypeOf(obj)) {
        var keys = Reflect.ownKeys(obj);
        keys.forEach(function (k) {
          return methods.push(k);
        });
      }

      return methods;
    }
  }, {
    key: "getAllFunctionNames",
    value: function getAllFunctionNames(obj) {
      var methods = [];
      (0, _each.default)(obj, function (property, name) {
        if (typeof property === 'function') {
          methods.push(name);
        }
      });
      return methods;
    }
  }, {
    key: "combineWheres",
    value: function combineWheres() {
      var and = [];

      for (var _len = arguments.length, wheres = new Array(_len), _key = 0; _key < _len; _key++) {
        wheres[_key] = arguments[_key];
      }

      wheres.forEach(function (where) {
        if (where) {
          and.push(where);
        }
      });

      if (and.length === 1) {
        return and[0];
      } else {
        return {
          $and: and
        };
      }
    }
  }, {
    key: "toWhereFromSearchString",
    value: function toWhereFromSearchString(attributes, string) {
      var trimmed = string.trim(); // Empty?

      if (trimmed === '') {
        return null;
      }

      var words = trimmed.split(/ +/);
      var ands = [];
      words.forEach(function (word) {
        var ors = [];
        attributes.forEach(function (attr) {
          ors.push((0, _defineProperty2.default)({}, attr, {
            // We need to use iLike as like is not case sensitive with binary (like JSON) data
            $iLike: word + '%'
          }));
        });
        ands.push({
          $or: ors
        });
      });
      return {
        $and: ands
      };
    }
  }, {
    key: "uuid",
    value: function uuid() {
      return _uuid2.default.v4();
    }
  }, {
    key: "once",
    value: function once(emitter, evnt) {
      return new Promise(function (resolve) {
        emitter.once(evnt, function () {
          resolve(arguments);
        });
      });
    }
  }, {
    key: "isRegExpString",
    value: function isRegExpString(string) {
      return new RegExp('^/(.*)/(.*)$').test(string);
    }
  }, {
    key: "stringToRegExp",
    value: function stringToRegExp(string) {
      // JSON doesn't support RegExp types so convert string representations to RegExp, including
      // flags
      var match = string.match(new RegExp('^/(.*)/(.*)$'));
      return new RegExp(match[1], match[2]);
    }
  }, {
    key: "toRegExp",
    value: function toRegExp(item) {
      return item instanceof RegExp ? item : this.stringToRegExp(item);
    }
  }, {
    key: "toSingular",
    value: function toSingular(plural) {
      // Automatically calculate singular label by removing last 's'
      return plural.substr(0, plural.length - 1);
    } // synchronize(synchronizer, promiseFactory) {
    //   const promise = synchronizer.then(() => {
    //     return promiseFactory();
    //   });
    //   synchronizer = synchronizer.then(() => promise);
    //   return promise;
    // }

  }]);
  return Utils;
}();

exports.Utils = Utils;

var _default = new Utils();

exports.default = _default;