"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _field = _interopRequireDefault(require("./fields/field"));

var _attach = _interopRequireDefault(require("./attach"));

var _access = _interopRequireDefault(require("mson/lib/access"));

var Form =
/*#__PURE__*/
function (_React$PureComponent) {
  (0, _inherits2.default)(Form, _React$PureComponent);
  (0, _createClass2.default)(Form, [{
    key: "turnOnAutoValidate",
    // Enable automatic validation whenever a user changes data. This feature allows the user to see
    // errors in real-time.
    value: function turnOnAutoValidate() {
      this.props.component.set({
        autoValidate: true
      });
    }
  }, {
    key: "calcFieldsCanAccess",
    value: function calcFieldsCanAccess() {
      var _this$props = this.props,
          component = _this$props.component,
          mode = _this$props.mode;
      var canDowngrade = true;

      var fieldsCanAccess = _access.default.fieldsCanAccess( // Default to update so that access control has a sensible default
      mode ? mode : 'update', component, null, canDowngrade); // We need to set the ignoreErrs state as there may be a field that is not accessible that is
      // generating an error.


      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = component.getFields()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var field = _step.value;
          var ignoreErrs = fieldsCanAccess[field.get('name')] === undefined;
          field.set({
            ignoreErrs: ignoreErrs
          });
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return fieldsCanAccess;
    }
  }, {
    key: "adjustAccess",
    value: function adjustAccess() {
      var fieldsCanAccess = null; // Was access specified? We check the form instead of this.props.access as this.props.access may
      // not have been updated yet.

      if (this.props.component.get('access')) {
        fieldsCanAccess = this.calcFieldsCanAccess();
      }

      this.setState({
        fieldsCanAccess: fieldsCanAccess
      });
    }
  }]);

  function Form(props) {
    var _this;

    (0, _classCallCheck2.default)(this, Form);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Form).call(this, props));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "state", {
      fieldsCanAccess: null
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleSave", function (event) {
      // Stop the form from refreshing the page. We can't rely on the default functionality as there
      // may be form errors that need to stop the form from submitting.
      event.preventDefault(); // No errors?

      var component = _this.props.component; // Is the submit action enabled?

      if (!component.get('disableSubmit')) {
        component.setTouched(true);
        component.validate();

        if (component.getErrs().length === 0) {
          component.submit();
        }
      }
    });

    _this.turnOnAutoValidate();

    if (props.access) {
      var fieldsCanAccess = _this.calcFieldsCanAccess();

      _this.state.fieldsCanAccess = fieldsCanAccess;
    }

    return _this;
  }

  (0, _createClass2.default)(Form, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var _this$props2 = this.props,
          component = _this$props2.component,
          access = _this$props2.access,
          mode = _this$props2.mode; // Did the form change?

      if (prevProps.component !== component) {
        this.turnOnAutoValidate();
      } // Did the access, mode or form change?


      if (prevProps.access !== access || prevProps.mode !== mode || prevProps.component !== component || prevProps.value !== this.props.value) {
        this.adjustAccess();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          component = _this$props3.component,
          formTag = _this$props3.formTag,
          isLoading = _this$props3.isLoading,
          disabled = _this$props3.disabled;
      var fieldsCanAccess = this.state.fieldsCanAccess;
      var fields = component.get('fields'); // Hide until the data has finished loading

      if (isLoading) {
        return null;
      } // The form key is needed or else React will not re-render all fields when the field indexes are
      // the same and we switch from route to another.


      var key = component.getKey();
      var flds = fields.map(function (field, index) {
        if (fieldsCanAccess === null || fieldsCanAccess[field.get('name')] !== undefined) {
          var accessEditable = null;

          if (fieldsCanAccess !== null && fieldsCanAccess[field.get('name')] === 'read') {
            accessEditable = false;
          }

          return _react.default.createElement(_field.default, {
            key: key + '_' + index,
            component: field,
            accessEditable: accessEditable,
            disabled: disabled
          });
        } else {
          return null;
        }
      });

      if (formTag !== false) {
        return _react.default.createElement("form", {
          onSubmit: this.handleSave
        }, flds);
      } else {
        return flds;
      }
    }
  }]);
  return Form;
}(_react.default.PureComponent);

var _default = (0, _attach.default)(['access', 'mode', 'isLoading', // We listen for a change to fields so that we can render when a field is added
'change', 'value'])(Form);

exports.default = _default;