"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _difference = _interopRequireDefault(require("lodash/difference"));

// Usage: attach(['prop1', 'prop2', ...], componentOrName)(Component)
var attach = function attach(_watchProps, componentOrName) {
  return function (Component) {
    var _temp;

    return _temp =
    /*#__PURE__*/
    function (_React$PureComponent) {
      (0, _inherits2.default)(_temp, _React$PureComponent);

      function _temp(_props) {
        var _this;

        (0, _classCallCheck2.default)(this, _temp);
        _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(_temp).call(this, _props)); // The field props that we want to expose in the state. Remove any names that are in
        // this.props so that we can override those values.

        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "wasMounted", false);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getComponent", function (props) {
          if (!props) {
            props = _this.props;
          }

          if (!componentOrName) {
            return props.component;
          } else if (typeof componentOrName === 'string') {
            return props[componentOrName];
          } else {
            // componentOrName is a component
            return componentOrName;
          }
        });
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleFieldChange", function (name, value) {
          if (_this.watchProps.indexOf(name) !== -1) {
            // Is the component mounted? Prevent a race condition where the handler tries to set the
            // state after the component has been unmounted.
            if (_this.wasMounted) {
              _this.setState((0, _defineProperty2.default)({}, name, value));
            }
          }
        });
        _this.watchProps = (0, _difference.default)(_watchProps, Object.keys(_this.props)); // These values need to be in the state so that the component is rerendered when they change.

        _this.state = _this.getComponent().get(_this.watchProps);
        return _this;
      }

      (0, _createClass2.default)(_temp, [{
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          if (this.getComponent() !== this.getComponent(prevProps)) {
            // The component is changing so recreate the listener
            this.removeListener();
            this.addListener(); // Set the initial state as the component has changed

            this.setInitialState();
          }
        }
      }, {
        key: "addListener",
        value: function addListener() {
          this.getComponent().on('$change', this.handleFieldChange);
        }
      }, {
        key: "removeListener",
        value: function removeListener() {
          this.getComponent().removeListener('$change', this.handleFieldChange);
        }
      }, {
        key: "setInitialState",
        value: function setInitialState() {
          var initialState = this.getComponent().get(this.watchProps);
          this.setState(initialState);
        }
      }, {
        key: "componentDidMount",
        value: function componentDidMount() {
          // Note: we have to use componentDidMount and not componentWillMount as handleFieldChange
          // can change the state and we aren't allowed to change the state until the component has
          // mounted.
          this.wasMounted = true;
          this.addListener(); // Update state with any changes that have occured since construction, but before mounting

          this.setInitialState();
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.removeListener();
          this.wasMounted = false;
        }
      }, {
        key: "render",
        value: function render() {
          return _react.default.createElement(Component, (0, _extends2.default)({}, this.state, this.props));
        }
      }]);
      return _temp;
    }(_react.default.PureComponent), _temp;
  };
};

var _default = attach;
exports.default = _default;