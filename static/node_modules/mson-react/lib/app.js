"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _withStyles = _interopRequireDefault(require("@material-ui/core/styles/withStyles"));

var _AppBar = _interopRequireDefault(require("@material-ui/core/AppBar"));

var _Tooltip = _interopRequireDefault(require("@material-ui/core/Tooltip"));

var _Toolbar = _interopRequireDefault(require("@material-ui/core/Toolbar"));

var _Typography = _interopRequireDefault(require("@material-ui/core/Typography"));

var _IconButton = _interopRequireDefault(require("@material-ui/core/IconButton"));

var _icon = _interopRequireDefault(require("./icon"));

var _menu = _interopRequireDefault(require("./menu"));

var _searchBar = _interopRequireDefault(require("./search-bar"));

var _reactRouterDom = require("react-router-dom");

var _component = _interopRequireDefault(require("./component"));

var _reactRouter = require("react-router");

var _withWidth = _interopRequireWildcard(require("@material-ui/core/withWidth"));

var _attach = _interopRequireDefault(require("./attach"));

var _globals = _interopRequireDefault(require("mson/lib/globals"));

var _snackbar = _interopRequireDefault(require("./snackbar"));

var _confirmationDialog = _interopRequireDefault(require("./confirmation-dialog"));

var _Switch = _interopRequireDefault(require("@material-ui/core/Switch"));

var _action = _interopRequireDefault(require("mson/lib/actions/action"));

var _collectionField = _interopRequireDefault(require("mson/lib/fields/collection-field"));

var _form = _interopRequireDefault(require("mson/lib/form"));

var _access = _interopRequireDefault(require("mson/lib/access"));

var _registrar = _interopRequireDefault(require("mson/lib/compiler/registrar"));

// TODO:
//   - On mobile when using search bar, display title and search icon. When user clicks icon then
//     hides title and allows for search string to be entered.
// import compiler from 'mson/lib/compiler';
// import UserMenu from './user-menu';
var drawerWidth = 240;

var styles = function styles(theme) {
  var _content;

  return {
    root: {
      width: '100%',
      // height: 430,
      // marginTop: theme.spacing.unit * 3,
      zIndex: 1,
      overflow: 'hidden'
    },
    appFrame: {
      position: 'relative',
      display: 'flex',
      width: '100%',
      height: '100%'
    },
    appBar: {
      position: 'fixed',
      marginLeft: drawerWidth
    },
    appBarResponsive: (0, _defineProperty2.default)({}, theme.breakpoints.up('md'), {
      width: "calc(100% - ".concat(drawerWidth, "px)")
    }),
    navIconHide: (0, _defineProperty2.default)({}, theme.breakpoints.up('md'), {
      display: 'none'
    }),
    content: (_content = {
      backgroundColor: theme.palette.background.default,
      width: '100%',
      padding: theme.spacing.unit * 3,
      height: 'calc(100% - 56px)',
      marginTop: 56
    }, (0, _defineProperty2.default)(_content, theme.breakpoints.up('sm'), {
      height: 'calc(100% - 64px)',
      marginTop: 64
    }), (0, _defineProperty2.default)(_content, "overflowAnchor", 'none'), _content),
    contentResponsive: (0, _defineProperty2.default)({}, theme.breakpoints.up('md'), {
      marginLeft: drawerWidth
    }),
    alignRight: {
      marginLeft: 'auto' // right align

    }
  };
}; // TODO: break up into components for header, menu, body, etc...


var App =
/*#__PURE__*/
function (_React$PureComponent) {
  (0, _inherits2.default)(App, _React$PureComponent);

  function App(props) {
    var _this;

    (0, _classCallCheck2.default)(this, App);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(App).call(this, props));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "state", {
      mobileOpen: false,
      menuItem: null,
      snackbarOpen: false,
      snackbarMessage: '',
      confirmationOpen: false,
      nextMenuItem: null,
      showArchivedToggle: false,
      // Note: we need both searchStringInput and globals.searchString as searchStringInput is the
      // controlled value for the text input and globals.searchString is the actual string with which
      // we are searching. These values not the same as we expect the user to submit the search before
      // it is performed so that we don't search on every keystroke. FUTURE: wait a little bit after
      // characters have been entered and then automatically search.
      searchStringInput: '',
      showSearch: false,
      showSearchOnMobile: false // isLoggedIn: false

    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "form", null);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "path", null);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onNavigate", function (callback) {
      // We don't warn about discarding changes when fullScreen, e.g. a login page
      var menuItem = _this.state.menuItem;

      if (menuItem && menuItem.content.has('dirty') && menuItem.content.get('dirty') && !menuItem.fullScreen) {
        // Show a confirmation dialog to see if the user wants to continue
        _globals.default.displayConfirmation({
          title: 'Discard changes?',
          callback: callback
        });
      } else {
        // Nothing is dirty so allow the navigation to continue
        callback(true);
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleDrawerToggle", function () {
      _this.setState({
        mobileOpen: !_this.state.mobileOpen
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleNavigate",
    /*#__PURE__*/
    function () {
      var _ref = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(menuItem, force) {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(menuItem.content instanceof _action.default)) {
                  _context.next = 5;
                  break;
                }

                _context.next = 3;
                return menuItem.content.run();

              case 3:
                _context.next = 6;
                break;

              case 5:
                _this.props.history.push(menuItem.path);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleConfirmationClose",
    /*#__PURE__*/
    function () {
      var _ref2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2(yes) {
        var confirmation;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                confirmation = _this.props.confirmation;

                if (confirmation.callback && yes) {
                  // Allow/prohibit the route change
                  confirmation.callback(yes);
                }

                _this.setState({
                  confirmationOpen: false
                });

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      return function (_x3) {
        return _ref2.apply(this, arguments);
      };
    }());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "switchContent",
    /*#__PURE__*/
    function () {
      var _ref3 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3(menuItem, parameters) {
        var isAction, _this$props, location, component, menu, parentItem, _this$canArchive, canArchive, canSearch;

        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(menuItem !== _this.state.menuItem)) {
                  _context3.next = 22;
                  break;
                }

                if (_this.component) {
                  // Emit an unload event so that the component can unload any data, etc...
                  _this.component.emitUnload();
                } // Note: menuItem can be null if there is no content on the landing page


                isAction = menuItem && menuItem.content instanceof _action.default; // Note: menuItem.content can be an action if the user goes directly to a route where the
                // content is an action

                if (!(menuItem && menuItem.content)) {
                  _context3.next = 21;
                  break;
                }

                _this$props = _this.props, location = _this$props.location, component = _this$props.component;
                menu = component.get('menu');

                _globals.default.set({
                  route: menu.toRoute({
                    parameters: parameters,
                    queryString: location.search.substr(1),
                    hash: location.hash.substr(1)
                  })
                });

                parentItem = menu.getParent(menuItem.path);

                if (!(_this.requireAccess(menuItem.roles) && (!parentItem || _this.requireAccess(parentItem.roles)))) {
                  _context3.next = 19;
                  break;
                }

                if (!isAction) {
                  _context3.next = 14;
                  break;
                }

                _context3.next = 12;
                return menuItem.content.run();

              case 12:
                _context3.next = 19;
                break;

              case 14:
                // Instantiate form
                // this.component = compiler.newComponent(menuItem.content.component);
                _this.component = menuItem.content; // Emit a load event so that the component can load any initial data, etc...

                _this.component.emitLoad();

                _this$canArchive = _this.canArchive(), canArchive = _this$canArchive.canArchive, canSearch = _this$canArchive.canSearch;

                _globals.default.set({
                  searchString: null
                }); // Set showArchived to false whenever we change the route


                _this.setState({
                  menuItem: menuItem,
                  showArchived: false,
                  showArchivedToggle: canArchive,
                  searchStringInput: '',
                  showSearch: canSearch
                });

              case 19:
                _context3.next = 22;
                break;

              case 21:
                _this.component = null;

              case 22:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      return function (_x4, _x5) {
        return _ref3.apply(this, arguments);
      };
    }());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onLocation", function (location) {
      _globals.default.set({
        path: location.pathname
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleSnackbarClose", function () {
      _this.setState({
        snackbarOpen: false
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleArchivedChange", function (event) {
      _this.setState({
        showArchived: event.target.checked
      });

      var menuItem = _this.state.menuItem;

      if (menuItem) {
        menuItem.content.set({
          showArchived: event.target.checked
        }); // Scroll to the top of the page as otherwise it is confusing to the user as to why they are
        // dumped in some random place within the newly queried data.

        window.scrollTo({
          top: 0
        });
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleSearchStringInputChange", function (searchStringInput) {
      _this.setState({
        searchStringInput: searchStringInput
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleSearch", function (searchStringInput) {
      _this.setState({
        searchStringInput: searchStringInput
      }, function () {
        _globals.default.set({
          searchString: searchStringInput ? searchStringInput : null
        });
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "toggleShowSearch", function () {
      _this.setState({
        showSearchOnMobile: !_this.state.showSearchOnMobile
      });
    });

    _this.setGlobalOnNavigate();

    return _this;
  }

  (0, _createClass2.default)(App, [{
    key: "setGlobalOnNavigate",
    value: function setGlobalOnNavigate() {
      _globals.default.setOnNavigate(this.onNavigate);
    }
  }, {
    key: "redirect",
    value: function redirect(path) {
      var history = this.props.history; // Clear the redirectPath so that back-to-back redirects to the same route are considered
      // unique, e.g. if / routes to /somepage and then the user hits back.

      _globals.default.set({
        redirectPath: null
      });

      history.push(path);
    }
  }, {
    key: "navigateTo",
    value: function navigateTo(path) {
      var menuItem = this.state.menuItem;
      var component = this.props.component;
      var menu = component.get('menu'); // if (path === '/home') {
      //   // Redirect so that user sees the actual path and not /home
      //   history.push(menu.getFirstItem().path);
      // } else

      if (!menuItem || path !== menuItem.path) {
        // if (this.requireAccess(menu.get('roles'))) {
        // The route is changing
        var item = menu.getItemAndParsePath(path);
        return this.switchContent(item.item, item.params); // }
      }
    }
  }, {
    key: "canArchive",
    value: function canArchive() {
      var canArchive = false;
      var canSearch = false;

      if (this.component && this.component instanceof _form.default) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.component.getFields()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var field = _step.value;

            if (field instanceof _collectionField.default) {
              canArchive = !field.get('forbidViewArchived') && _access.default.canArchive(field.get('form'));
              canSearch = !field.get('forbidSearch');
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return {
        canArchive: canArchive,
        canSearch: canSearch
      };
    }
  }, {
    key: "emitLoggedOut",
    value: function emitLoggedOut() {
      _globals.default.set({
        redirectAfterLogin: this.props.location.pathname
      });

      this.props.component.emitLoggedOut();
    }
  }, {
    key: "requireAccess",
    value: function requireAccess(roles) {
      var canAccess = !roles || _registrar.default.client && _registrar.default.client.user.hasRole(roles);

      if (!canAccess) {
        this.emitLoggedOut();
      }

      return canAccess;
    }
  }, {
    key: "componentWillUpdate",
    // TODO: move logic to componentDidUpdate
    value: function componentWillUpdate(props) {
      var snackbarMessage = _globals.default.get('snackbarMessage');

      if (snackbarMessage) {
        this.displaySnackbar(snackbarMessage);

        _globals.default.set({
          snackbarMessage: null
        });
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props.redirectPath && this.props.redirectPath !== prevProps.redirectPath) {
        this.redirect(this.props.redirectPath);
      }

      if (this.props.path !== prevProps.path) {
        this.navigateTo(this.props.path);
      }

      if (this.props.confirmation !== prevProps.confirmation) {
        // Show the popup if any of the confirmation info has changed
        this.setState({
          confirmationOpen: true
        });
      }

      if (this.props.searchString !== prevProps.searchString) {
        // Pass search string down to current component
        var menuItem = this.state.menuItem;

        if (menuItem && menuItem.content.has('searchString')) {
          menuItem.content.set({
            searchString: this.props.searchString
          });
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      // TODO: is this too inefficient in that it cascades a lot of unecessary events? Instead, could:
      // 1. move more logic to app layer so that only cascade when need new window 2. use something
      // like a global scroll listener that the component can use when it is active
      window.addEventListener('scroll', function (e) {
        if (_this2.state.menuItem) {
          _this2.state.menuItem.content.emit('scroll', e);
        }
      }); // Handle immediate redirects, e.g. if user is not logged in

      if (this.props.redirectPath) {
        this.redirect(this.props.redirectPath);
      }
    }
  }, {
    key: "componentWillMount",
    value: function componentWillMount() {
      var _this3 = this;

      // Allows us to listen to back and forward button clicks
      this.unlisten = this.props.history.listen(this.onLocation);
      Promise.resolve().then(function () {
        if (_registrar.default.client) {
          // Wait for the session to load before loading the initial component so that we can do things
          // like route based on a user's role
          _registrar.default.client.user.awaitSession();
        }
      }).then(function () {
        // Load the correct component based on the initial path
        _this3.onLocation(_this3.props.location);
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unlisten();
    }
  }, {
    key: "displaySnackbar",
    value: function displaySnackbar(message) {
      this.setState({
        snackbarOpen: true,
        snackbarMessage: message
      });
    }
  }, {
    key: "archivedToggle",
    value: function archivedToggle() {
      var _this$state = this.state,
          showArchived = _this$state.showArchived,
          showArchivedToggle = _this$state.showArchivedToggle; // A component must not switch from controlled to uncontrolled so we need to avoid setting
      // checked=undefined

      var showArchivedChecked = showArchived ? true : false;
      var archivedToggle = null;

      if (showArchivedToggle) {
        archivedToggle = _react.default.createElement(_Tooltip.default, {
          title: showArchived ? 'Show Active' : 'Show Deleted'
        }, _react.default.createElement(_Switch.default, {
          onChange: this.handleArchivedChange,
          checked: showArchivedChecked
        }));
      }

      return archivedToggle;
    }
  }, {
    key: "searchBox",
    value: function searchBox(fullWidth) {
      var classes = this.props.classes;
      var _this$state2 = this.state,
          searchStringInput = _this$state2.searchStringInput,
          showSearch = _this$state2.showSearch;
      var searchBox = null;

      if (showSearch) {
        searchBox = _react.default.createElement(_searchBar.default, {
          fullWidth: fullWidth,
          className: classes.alignRight,
          searchString: searchStringInput,
          onChange: this.handleSearchStringInputChange,
          onSearch: this.handleSearch
        });
      }

      return searchBox;
    }
  }, {
    key: "menuButton",
    value: function menuButton() {
      var classes = this.props.classes;
      var responsive = this.isResponsive();
      return _react.default.createElement(_IconButton.default, {
        color: "inherit",
        "aria-label": "open drawer",
        onClick: this.handleDrawerToggle,
        className: responsive ? classes.navIconHide : ''
      }, _react.default.createElement(_icon.default, {
        icon: "Menu"
      }));
    }
  }, {
    key: "title",
    value: function title() {
      var menuItem = this.state.menuItem;
      return _react.default.createElement(_Typography.default, {
        variant: "h6",
        color: "inherit",
        noWrap: true
      }, menuItem ? menuItem.label : '');
    }
  }, {
    key: "appBar",
    value: function appBar() {
      var _this$props2 = this.props,
          classes = _this$props2.classes,
          width = _this$props2.width;
      var showSearchOnMobile = this.state.showSearchOnMobile;
      var onMobile = (0, _withWidth.isWidthDown)('sm', width);
      var responsive = this.isResponsive();
      var bar = null;

      if (onMobile) {
        if (showSearchOnMobile) {
          bar = _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_IconButton.default, {
            color: "inherit",
            "aria-label": "close search",
            onClick: this.toggleShowSearch
          }, _react.default.createElement(_icon.default, {
            icon: "ArrowBack"
          })), this.searchBox(true));
        } else {
          bar = _react.default.createElement(_react.default.Fragment, null, this.menuButton(), this.title(), this.archivedToggle(), _react.default.createElement(_IconButton.default, {
            color: "inherit",
            "aria-label": "toggle search",
            onClick: this.toggleShowSearch,
            className: classes.alignRight
          }, _react.default.createElement(_icon.default, {
            icon: "Search"
          })));
        }
      } else {
        bar = _react.default.createElement(_react.default.Fragment, null, this.menuButton(), this.title(), this.archivedToggle(), this.searchBox());
      }

      return _react.default.createElement(_AppBar.default, {
        elevation: 1 // tone down the elevation
        ,
        className: classes.appBar + (responsive ? " ".concat(classes.appBarResponsive) : '')
      }, _react.default.createElement(_Toolbar.default, null, bar));
    }
  }, {
    key: "isResponsive",
    value: function isResponsive() {
      return !this.props.menuAlwaysTemporary;
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          classes = _this$props3.classes,
          component = _this$props3.component,
          confirmation = _this$props3.confirmation;
      var _this$state3 = this.state,
          mobileOpen = _this$state3.mobileOpen,
          menuItem = _this$state3.menuItem,
          snackbarOpen = _this$state3.snackbarOpen,
          snackbarMessage = _this$state3.snackbarMessage,
          confirmationOpen = _this$state3.confirmationOpen;
      var responsive = this.isResponsive();
      var menu = component.get('menu'); // Use the path from the location prop as this.state.path may not be up to date

      var path = this.props.location.pathname;
      var comp = this.component ? _react.default.createElement(_component.default, {
        component: this.component
      }) : null;
      var appBar = this.appBar();

      var menuSidebar = _react.default.createElement(_menu.default, {
        component: menu,
        onDrawerToggle: this.handleDrawerToggle,
        mobileOpen: mobileOpen,
        onNavigate: this.handleNavigate,
        path: path,
        responsive: responsive
      });

      var fullScreenStyle = null;

      if (menuItem && menuItem.fullScreen) {
        fullScreenStyle = {
          marginLeft: 0,
          marginTop: 0
        };
      }

      return _react.default.createElement("div", {
        className: classes.root
      }, _react.default.createElement("div", {
        className: classes.appFrame
      }, menuItem && menuItem.fullScreen ? null : appBar, menuItem && menuItem.fullScreen ? null : menuSidebar, _react.default.createElement("main", {
        className: classes.content + (responsive ? " ".concat(classes.contentResponsive) : ''),
        style: fullScreenStyle
      }, _react.default.createElement(_reactRouterDom.Switch, null, _react.default.createElement(_reactRouterDom.Route, null)), comp, _react.default.createElement(_snackbar.default, {
        open: snackbarOpen,
        message: snackbarMessage,
        onClose: this.handleSnackbarClose
      }), _react.default.createElement(_confirmationDialog.default, {
        open: confirmationOpen,
        onClose: this.handleConfirmationClose,
        title: confirmation ? confirmation.title : null,
        text: confirmation ? confirmation.text : null,
        alert: confirmation ? confirmation.alert : null
      }))));
    }
  }]);
  return App;
}(_react.default.PureComponent);

App = (0, _withStyles.default)(styles, {
  withTheme: true
})(App);
App = (0, _withWidth.default)()(App);
App = (0, _reactRouter.withRouter)(App);
App = (0, _attach.default)(['menuAlwaysTemporary'])(App);
App = (0, _attach.default)(['path', 'redirectPath', 'snackbarMessage', 'confirmation', 'searchString'], _globals.default)(App);
var _default = App;
exports.default = _default;