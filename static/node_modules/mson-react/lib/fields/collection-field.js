"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _react = _interopRequireDefault(require("react"));

var _Grid = _interopRequireDefault(require("@material-ui/core/Grid"));

var _formCard = _interopRequireDefault(require("../form-card"));

var _formDialog = _interopRequireDefault(require("../form-dialog"));

var _attach = _interopRequireDefault(require("../attach"));

var _button = _interopRequireDefault(require("../button"));

var _Typography = _interopRequireDefault(require("@material-ui/core/Typography"));

var _confirmationDialog = _interopRequireDefault(require("../confirmation-dialog"));

var _access = _interopRequireDefault(require("mson/lib/access"));

var _withStyles = _interopRequireDefault(require("@material-ui/core/styles/withStyles"));

require("./collection-field.css");

var _selectOrder = _interopRequireDefault(require("./select-order"));

var _buttonField = _interopRequireDefault(require("mson/lib/fields/button-field"));

var _icon = _interopRequireDefault(require("../icon"));

var _commonField = _interopRequireDefault(require("./common-field"));

var _reactBeautifulDnd = require("react-beautiful-dnd");

var getItemStyle = function getItemStyle(isDragging, draggableStyle, theme) {
  return (0, _objectSpread2.default)({
    // some basic styles to make the items look a bit nicer
    userSelect: 'none',
    padding: theme.spacing.unit / 8,
    margin: "0 0 ".concat(theme.spacing.unit / 8, "px 0"),
    // change background colour if dragging
    background: isDragging ? theme.palette.secondary[400] : undefined
  }, draggableStyle);
};

var getListStyle = function getListStyle(isDraggingOver, theme) {
  return {
    background: isDraggingOver ? theme.palette.grey[300] : undefined,
    width: '100%'
  };
}; // Note:
//   - We use a dialog to view/edit the forms as we want to be able to display just a few pieces
//     of data in the list and all the data when viewing/editing.


var styles = function styles(theme) {
  return {
    root: {
      // Needed when field is nested in a form that is nested in a form, e.g. FormEditor
      width: '100%'
    },
    spacer: {
      backgroundColor: theme.palette.grey[300],
      marginLeft: theme.spacing.unit,
      marginRight: theme.spacing.unit,
      animation: 'fadeIn 1s infinite alternate'
    },
    footer: {
      // Create space at the footer so that it is more evident to the user that the next page has been
      // loaded
      height: 50,
      backgroundColor: theme.palette.grey[300],
      margin: theme.spacing.unit,
      animation: 'fadeIn 1s infinite alternate'
    }
  };
};

var CollectionField =
/*#__PURE__*/
function (_React$PureComponent) {
  (0, _inherits2.default)(CollectionField, _React$PureComponent);

  function CollectionField() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, CollectionField);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(CollectionField)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "state", {
      confirmationOpen: false,
      sortBy: '',
      sortOrder: 'ASC'
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleClose", function () {
      _this.props.component.set({
        mode: null
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleCancel", function (form) {
      var component = _this.props.component;

      if (component.get('skipRead')) {
        component.set({
          mode: null
        });
      } else {
        component.set({
          currentForm: form,
          mode: 'read'
        });
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleClick", function (form) {
      var component = _this.props.component;

      if (component.get('skipRead')) {
        component.set({
          currentForm: form,
          mode: 'update'
        });
      } else {
        component.set({
          currentForm: form,
          mode: 'read'
        });
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleEdit", function (form) {
      _this.props.component.set({
        currentForm: form,
        mode: 'update'
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleNew", function () {
      _this.props.component.set({
        currentForm: null,
        mode: 'create'
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleSave",
    /*#__PURE__*/
    (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee() {
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _this.props.component.save();

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleDelete",
    /*#__PURE__*/
    function () {
      var _ref2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2(formToDelete) {
        var component, open, archivedAt;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                component = _this.props.component;
                open = _this.isOpen();

                if (formToDelete) {
                  component.set({
                    currentForm: formToDelete
                  });
                } else {
                  // Are we already focussed on this form
                  formToDelete = component.get('form');
                }

                archivedAt = formToDelete.getValue('archivedAt'); // Are we restoring?

                if (!archivedAt) {
                  _context2.next = 10;
                  break;
                }

                _context2.next = 7;
                return component.restore(formToDelete);

              case 7:
                // Is the dialog open?
                if (open) {
                  // Close it
                  component.set({
                    mode: null
                  });
                }

                _context2.next = 12;
                break;

              case 10:
                _this.setState({
                  confirmationOpen: true,
                  // confirmationTitle: `Are you sure you want to delete this ${singularLabel}?`
                  confirmationTitle: 'Delete this?'
                });

                component.set({
                  mode: null
                });

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      return function (_x) {
        return _ref2.apply(this, arguments);
      };
    }());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleConfirmationClose",
    /*#__PURE__*/
    function () {
      var _ref3 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3(yes) {
        var component;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!yes) {
                  _context3.next = 4;
                  break;
                }

                component = _this.props.component;
                _context3.next = 4;
                return component.archive(component.get('form'));

              case 4:
                _this.setState({
                  confirmationOpen: false
                });

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      return function (_x2) {
        return _ref3.apply(this, arguments);
      };
    }());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleOrdering", function (props) {
      // TODO: shouldn't the ordering just be in the field and not have to be in this state?
      _this.setState(props, function () {
        _this.props.component.set({
          order: _this.state.sortBy ? [[_this.state.sortBy, _this.state.sortOrder]] : null
        });
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onDragEnd", function (result) {
      // dropped outside the list
      if (!result.destination) {
        return;
      }

      if (result.destination.index !== result.source.index) {
        _this.props.component.moveAndSaveForm({
          sourceIndex: result.source.index,
          destinationIndex: result.destination.index
        });
      }
    });
    return _this;
  }

  (0, _createClass2.default)(CollectionField, [{
    key: "isOpen",
    value: function isOpen() {
      return !!this.props.mode;
    }
  }, {
    key: "canCreate",
    value: function canCreate() {
      return _access.default.canCreate(this.props.component.get('form'));
    }
  }, {
    key: "canUpdate",
    value: function canUpdate() {
      return _access.default.canUpdate(this.props.component.get('form'));
    }
  }, {
    key: "canArchive",
    value: function canArchive() {
      return _access.default.canArchive(this.props.component.get('form'));
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props.bufferTopId !== prevProps.bufferTopId) {
        // Resize the spacer now that the newly prepended items have been rendered
        this.props.component._infiniteLoader.resizeSpacer(this.props.bufferTopId);
      }

      if (this.props.spacerHeight !== prevProps.spacerHeight) {
        this.props.component._infiniteLoader.setSpacerResizing(false);
      }

      if (this.props.change !== prevProps.change) {
        this.props.component.set({
          isLoading: false
        });
      }
    }
  }, {
    key: "canDrag",
    value: function canDrag() {
      var _this$props = this.props,
          forbidOrder = _this$props.forbidOrder,
          showArchived = _this$props.showArchived,
          searchString = _this$props.searchString,
          order = _this$props.order; // Can we order by dragging?

      return !forbidOrder && !showArchived && !searchString && !order;
    }
  }, {
    key: "cards",
    value: function cards(canUpdate, canArchive) {
      var _this2 = this;

      var _this$props2 = this.props,
          component = _this$props2.component,
          forbidUpdate = _this$props2.forbidUpdate,
          forbidDelete = _this$props2.forbidDelete,
          forbidOrder = _this$props2.forbidOrder,
          editable = _this$props2.editable,
          disabled = _this$props2.disabled,
          useDisplayValue = _this$props2.useDisplayValue,
          theme = _this$props2.theme; // Force to 1 colum when ordering allowed

      var maxColumns = forbidOrder === false ? 1 : this.props.maxColumns;
      var maxGrids = 12 / maxColumns;
      var cards = [];
      var index = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function _loop() {
          var form = _step.value;
          // TODO: Rendering should not change form. Use utils.getIfDefined() in form to allow passing
          // in of editable via React layer
          form.setEditable(false); // We need to use the id for the key as we use the same list of cards when toggling
          // showArchive

          var key = form.getUniqueId(); // Note: we use an id instead of ref so that more of our logic can be reused across different
          // frameworks. We use the form id so that we have a consistent way of referencing the element
          // for things like infinite loading.

          var id = component.getUniqueItemId(form.getValue('id'));

          var item = _react.default.createElement(_Grid.default, {
            item: true,
            xs: 12,
            sm: maxGrids,
            lg: maxGrids,
            key: key,
            id: id
          }, _react.default.createElement(_formCard.default, {
            onClick: function onClick() {
              return _this2.handleClick(form);
            },
            onEdit: function onEdit() {
              return _this2.handleEdit(form);
            },
            onDelete: _this2.handleDelete,
            component: form,
            forbidUpdate: forbidUpdate || !canUpdate || useDisplayValue,
            forbidDelete: forbidDelete || !canArchive || useDisplayValue,
            editable: editable,
            disabled: disabled
          }));

          if (_this2.canDrag()) {
            cards.push(_react.default.createElement(_reactBeautifulDnd.Draggable, {
              key: id,
              draggableId: id,
              index: index++
            }, function (provided, snapshot) {
              return _react.default.createElement("div", (0, _extends2.default)({
                ref: provided.innerRef
              }, provided.draggableProps, provided.dragHandleProps, {
                style: getItemStyle(snapshot.isDragging, provided.draggableProps.style, theme)
              }), item);
            }));
          } else {
            cards.push(item);
          }
        };

        for (var _iterator = component.getForms()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return cards;
    }
  }, {
    key: "sortOptions",
    value: function sortOptions() {
      var component = this.props.component;

      if (component && component.get('form')) {
        var form = component.get('form');

        var fieldsCanAccess = _access.default.fieldsCanAccess('read', form);

        var fields = [];
        form.eachField(function (field) {
          var name = field.get('name'); // Do we have access to the field? Allowed to sort? Not hidden? Not a button?

          if (fieldsCanAccess[name] !== undefined && !field.get('forbidSort') && !field.get('hidden') && !(field instanceof _buttonField.default)) {
            fields.push({
              value: (form.isDefaultField(name) ? '' : 'fieldValues.') + name,
              label: field.get('label')
            });
          }
        });
        return fields;
      }
    }
  }, {
    key: "header",
    value: function header(numCards) {
      var _this$props3 = this.props,
          forbidCreate = _this$props3.forbidCreate,
          editable = _this$props3.editable,
          disabled = _this$props3.disabled,
          component = _this$props3.component,
          forbidSort = _this$props3.forbidSort,
          store = _this$props3.store,
          useDisplayValue = _this$props3.useDisplayValue;
      var _this$state = this.state,
          sortBy = _this$state.sortBy,
          sortOrder = _this$state.sortOrder;
      var singularLabel = component.getSingularLabel();
      var reachedMax = component.reachedMax();
      var canCreate = this.canCreate();
      var showNewButton = editable && !disabled && !useDisplayValue && !forbidCreate && !reachedMax && canCreate;
      var canOrder = !forbidSort;
      var sortOptions = this.sortOptions(); // Sorting only works when there is a backing store

      var hasStore = !!store;
      var showOrder = numCards > 0 && hasStore;
      return _react.default.createElement(_Grid.default, {
        container: true,
        spacing: 0
      }, _react.default.createElement(_Grid.default, {
        item: true,
        xs: 12,
        sm: 6,
        lg: 6
      }, showNewButton ? _react.default.createElement(_button.default, {
        "aria-label": "new",
        onClick: this.handleNew,
        icon: "Add",
        label: 'New ' + singularLabel,
        marginTop: false
      }) : null), _react.default.createElement(_Grid.default, {
        item: true,
        xs: 12,
        sm: 6,
        lg: 6,
        align: "right"
      }, showOrder && canOrder ? _react.default.createElement(_selectOrder.default, {
        onChange: this.handleOrdering,
        sortBy: sortBy,
        sortOrder: sortOrder,
        options: sortOptions
      }) : null));
    }
  }, {
    key: "field",
    // TODO: how to prevent re-rendering of all form-cards when dialog open state is changed? Or, does
    // it not really matter as we are using PureComponents?
    value: function field() {
      var _this$props4 = this.props,
          forbidUpdate = _this$props4.forbidUpdate,
          forbidDelete = _this$props4.forbidDelete,
          component = _this$props4.component,
          spacerHeight = _this$props4.spacerHeight,
          classes = _this$props4.classes,
          isLoading = _this$props4.isLoading,
          form = _this$props4.form,
          currentForm = _this$props4.currentForm,
          noResults = _this$props4.noResults,
          disabled = _this$props4.disabled,
          accessEditable = _this$props4.accessEditable,
          useDisplayValue = _this$props4.useDisplayValue,
          theme = _this$props4.theme;
      var dis = accessEditable === false || disabled;
      var _this$state2 = this.state,
          confirmationOpen = _this$state2.confirmationOpen,
          confirmationTitle = _this$state2.confirmationTitle;
      var label = component.get('label').toLowerCase();
      var canUpdate = this.canUpdate();
      var canArchive = this.canArchive();
      var spacerStyle = {
        height: spacerHeight
      };
      var spacerId = component.get('spacerId');
      var cards = this.cards(canUpdate, canArchive);
      var cardContainer = cards;

      if (this.canDrag()) {
        cardContainer = _react.default.createElement(_reactBeautifulDnd.DragDropContext, {
          onDragEnd: this.onDragEnd
        }, _react.default.createElement(_reactBeautifulDnd.Droppable, {
          droppableId: "droppable"
        }, function (provided, snapshot) {
          return _react.default.createElement("div", {
            ref: provided.innerRef,
            style: getListStyle(snapshot.isDraggingOver, theme)
          }, cards, provided.placeholder);
        }));
      }

      var searchString = component.get('searchString'); // Is the user searching and there are no records?

      var showNoRecords = searchString && noResults;
      var header = this.header(cards.length);
      return _react.default.createElement("div", null, header, showNoRecords ? _react.default.createElement(_Typography.default, {
        variant: "h4"
      }, _react.default.createElement(_icon.default, {
        icon: "Info"
      }), " No ", label, " found") : null, _react.default.createElement("div", {
        id: spacerId,
        className: classes.spacer,
        style: spacerStyle
      }), _react.default.createElement(_Grid.default, {
        container: true,
        spacing: 0
      }, cardContainer), isLoading ? _react.default.createElement("div", {
        className: classes.footer
      }) : null, _react.default.createElement(_formDialog.default, {
        component: form,
        currentForm: currentForm,
        onClose: this.handleClose,
        onCancel: this.handleCancel,
        onSave: this.handleSave,
        onEdit: this.handleEdit,
        onDelete: this.handleDelete,
        forbidUpdate: forbidUpdate || !canUpdate || dis || useDisplayValue,
        forbidDelete: forbidDelete || !canArchive || dis || useDisplayValue
      }), _react.default.createElement(_confirmationDialog.default, {
        open: confirmationOpen,
        onClose: this.handleConfirmationClose,
        title: confirmationTitle
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props5 = this.props,
          component = _this$props5.component,
          hideLabel = _this$props5.hideLabel,
          classes = _this$props5.classes;
      var isBlank = component.isBlank();
      return _react.default.createElement("span", {
        className: classes.root
      }, !hideLabel && _react.default.createElement(_commonField.default, {
        component: component,
        inlineLabel: "true",
        shrinkLabel: !isBlank
      }), this.field());
    }
  }]);
  return CollectionField;
}(_react.default.PureComponent);

CollectionField = (0, _withStyles.default)(styles, {
  withTheme: true
})(CollectionField);
CollectionField = (0, _attach.default)(['change', 'label', 'singularLabel', 'forbidCreate', 'forbidUpdate', 'forbidDelete', 'forbidSort', 'forbidOrder', 'editable', 'disabled', 'spacerHeight', 'bufferTopId', 'isLoading', 'form', 'currentForm', 'mode', 'noResults', 'store', 'maxColumns', 'useDisplayValue', 'hideLabel', 'showArchived', 'searchString', 'order'])(CollectionField);
var _default = CollectionField;
exports.default = _default;